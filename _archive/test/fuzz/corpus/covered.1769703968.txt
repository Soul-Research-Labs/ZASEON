/Users/manishghimire/Downloads/Soul Protocol/contracts/crosschain/EthereumL1Bridge.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "@openzeppelin/contracts/access/AccessControl.sol";
   5 |     | import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
   6 |     | import "@openzeppelin/contracts/utils/Pausable.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @title EthereumL1Bridge
  10 |     |  * @author Soul Protocol
  11 |     |  * @notice Bridge adapter for Ethereum mainnet (L1) interoperability
  12 |     |  * @dev Handles cross-chain proof relay and state synchronization between Soul and Ethereum L1
  13 |     |  *
  14 |     |  * ARCHITECTURE:
  15 |     |  * ┌─────────────────────────────────────────────────────────────────┐
  16 |     |  * │                    Ethereum L1 Bridge                           │
  17 |     |  * ├─────────────────────────────────────────────────────────────────┤
  18 |     |  * │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
  19 |     |  * │  │  Deposit    │  │  Withdraw   │  │  Proof      │             │
  20 |     |  * │  │  Manager    │  │  Manager    │  │  Relay      │             │
  21 |     |  * │  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘             │
  22 |     |  * │         │                │                │                     │
  23 |     |  * │  ┌──────▼────────────────▼────────────────▼──────┐             │
  24 |     |  * │  │              State Commitment Engine           │             │
  25 |     |  * │  └────────────────────────────────────────────────┘             │
  26 |     |  * │         │                                                       │
  27 |     |  * │  ┌──────▼──────────────────────────────────────────┐           │
  28 |     |  * │  │           L2/Rollup Canonical Bridges           │           │
  29 |     |  * │  │  Arbitrum | Optimism | zkSync | Base | Scroll   │           │
  30 |     |  * │  └─────────────────────────────────────────────────┘           │
  31 |     |  * └─────────────────────────────────────────────────────────────────┘
  32 |     |  *
  33 |     |  * SECURITY PROPERTIES:
  34 |     |  * - Uses canonical L2 bridges for finality guarantees
  35 |     |  * - Implements optimistic fraud proof window
  36 |     |  * - Supports EIP-4844 blob data for cost efficiency
  37 |     |  * - Rate limiting and circuit breakers for attack mitigation
  38 |     |  */
  39 | *   | contract EthereumL1Bridge is AccessControl, ReentrancyGuard, Pausable {
  40 |     |     /*//////////////////////////////////////////////////////////////
  41 |     |                                  ROLES
  42 |     |     //////////////////////////////////////////////////////////////*/
  43 |     | 
  44 | *   |     bytes32 public constant RELAYER_ROLE = keccak256("RELAYER_ROLE");
  45 | *   |     bytes32 public constant OPERATOR_ROLE = keccak256("OPERATOR_ROLE");
  46 | *   |     bytes32 public constant GUARDIAN_ROLE = keccak256("GUARDIAN_ROLE");
  47 |     | 
  48 |     |     /*//////////////////////////////////////////////////////////////
  49 |     |                                  TYPES
  50 |     |     //////////////////////////////////////////////////////////////*/
  51 |     | 
  52 |     |     /// @notice Supported L2 rollup types
  53 |     |     enum RollupType {
  54 |     |         OPTIMISTIC, // Arbitrum, Optimism, Base
  55 |     |         ZK_ROLLUP, // zkSync Era, Scroll, Linea, Polygon zkEVM
  56 |     |         VALIDIUM // Data availability off-chain
  57 |     |     }
  58 |     | 
  59 |     |     /// @notice State commitment status
  60 |     |     enum CommitmentStatus {
  61 |     |         PENDING,
  62 |     |         CHALLENGED,
  63 |     |         FINALIZED,
  64 |     |         REJECTED
  65 |     |     }
  66 |     | 
  67 |     |     /// @notice L2 chain configuration
  68 |     |     struct L2Config {
  69 |     |         uint256 chainId;
  70 |     |         string name;
  71 |     |         RollupType rollupType;
  72 |     |         address canonicalBridge;
  73 |     |         address messenger;
  74 |     |         address stateCommitmentChain;
  75 |     |         uint256 challengePeriod; // For optimistic rollups
  76 |     |         uint256 confirmationBlocks;
  77 |     |         bool enabled;
  78 |     |         uint256 gasLimit;
  79 |     |         uint256 lastSyncedBlock;
  80 |     |     }
  81 |     | 
  82 |     |     /// @notice Cross-chain state commitment
  83 |     |     struct StateCommitment {
  84 |     |         bytes32 commitmentId;
  85 |     |         uint256 sourceChainId;
  86 |     |         bytes32 stateRoot;
  87 |     |         bytes32 proofRoot;
  88 |     |         uint256 blockNumber;
  89 |     |         uint256 timestamp;
  90 |     |         CommitmentStatus status;
  91 |     |         uint256 challengeDeadline;
  92 |     |         address submitter;
  93 |     |         bytes32 blobVersionedHash; // EIP-4844 support
  94 |     |     }
  95 |     | 
  96 |     |     /// @notice Deposit record for L1 -> L2 transfers
  97 |     |     struct Deposit {
  98 |     |         bytes32 depositId;
  99 |     |         address depositor;
 100 |     |         uint256 targetChainId;
 101 |     |         address token;
 102 |     |         uint256 amount;
 103 |     |         bytes32 commitment; // Soul commitment for privacy
 104 |     |         uint256 timestamp;
 105 |     |         bool claimed;
 106 |     |     }
 107 |     | 
 108 |     |     /// @notice Withdrawal record for L2 -> L1 transfers
 109 |     |     struct Withdrawal {
 110 |     |         bytes32 withdrawalId;
 111 |     |         address recipient;
 112 |     |         uint256 sourceChainId;
 113 |     |         address token;
 114 |     |         uint256 amount;
 115 |     |         bytes32 nullifier; // Soul nullifier to prevent double-spend
 116 |     |         bytes32[] proof; // Merkle proof from L2
 117 |     |         uint256 timestamp;
 118 |     |         bool finalized;
 119 |     |         bool claimed;
 120 |     |     }
 121 |     | 
 122 |     |     /*//////////////////////////////////////////////////////////////
 123 |     |                                 STORAGE
 124 |     |     //////////////////////////////////////////////////////////////*/
 125 |     | 
 126 |     |     /// @notice L2 chain configurations
 127 |     |     mapping(uint256 => L2Config) public l2Configs;
 128 |     | 
 129 |     |     /// @notice Supported chain IDs
 130 |     |     uint256[] public supportedChainIds;
 131 |     | 
 132 |     |     /// @notice State commitments from L2 chains
 133 |     |     mapping(bytes32 => StateCommitment) public stateCommitments;
 134 |     | 
 135 |     |     /// @notice Chain ID -> latest state root
 136 |     |     mapping(uint256 => bytes32) public latestStateRoots;
 137 |     | 
 138 |     |     /// @notice Deposits by ID
 139 |     |     mapping(bytes32 => Deposit) public deposits;
 140 |     | 
 141 |     |     /// @notice Withdrawals by ID
 142 |     |     mapping(bytes32 => Withdrawal) public withdrawals;
 143 |     | 
 144 |     |     /// @notice Used nullifiers (cross-chain double-spend prevention)
 145 |     |     mapping(bytes32 => bool) public usedNullifiers;
 146 |     | 
 147 |     |     /// @notice Relayed proof hashes
 148 |     |     mapping(bytes32 => bool) public relayedProofs;
 149 |     | 
 150 |     |     /// @notice Ethereum mainnet chain ID (immutable)
 151 |     |     uint256 public constant ETHEREUM_CHAIN_ID = 1;
 152 |     | 
 153 |     |     /// @notice Challenge period for optimistic commitments (default: 7 days)
 154 |     |     uint256 public constant DEFAULT_CHALLENGE_PERIOD = 7 days;
 155 |     | 
 156 |     |     /// @notice Minimum bond for state commitment submission
 157 | *   |     uint256 public minSubmissionBond = 0.1 ether;
 158 |     | 
 159 |     |     /// @notice Rate limiting: max commitments per hour
 160 | *   |     uint256 public maxCommitmentsPerHour = 100;
 161 |     |     uint256 public hourlyCommitmentCount;
 162 |     |     uint256 public lastHourReset;
 163 |     | 
 164 |     |     /// @notice Total deposits count
 165 |     |     uint256 public totalDeposits;
 166 |     | 
 167 |     |     /// @notice Total withdrawals count
 168 |     |     uint256 public totalWithdrawals;
 169 |     | 
 170 |     |     /// @notice Total state commitments
 171 |     |     uint256 public totalCommitments;
 172 |     | 
 173 |     |     /*//////////////////////////////////////////////////////////////
 174 |     |                                 EVENTS
 175 |     |     //////////////////////////////////////////////////////////////*/
 176 |     | 
 177 |     |     event L2ChainConfigured(
 178 |     |         uint256 indexed chainId,
 179 |     |         string name,
 180 |     |         RollupType rollupType,
 181 |     |         address canonicalBridge
 182 |     |     );
 183 |     | 
 184 |     |     event L2ChainUpdated(uint256 indexed chainId, bool enabled);
 185 |     | 
 186 |     |     event StateCommitmentSubmitted(
 187 |     |         bytes32 indexed commitmentId,
 188 |     |         uint256 indexed sourceChainId,
 189 |     |         bytes32 stateRoot,
 190 |     |         address submitter,
 191 |     |         bytes32 blobVersionedHash
 192 |     |     );
 193 |     | 
 194 |     |     event StateCommitmentChallenged(
 195 |     |         bytes32 indexed commitmentId,
 196 |     |         address challenger,
 197 |     |         bytes32 reason
 198 |     |     );
 199 |     | 
 200 |     |     event StateCommitmentFinalized(
 201 |     |         bytes32 indexed commitmentId,
 202 |     |         bytes32 stateRoot
 203 |     |     );
 204 |     | 
 205 |     |     event DepositInitiated(
 206 |     |         bytes32 indexed depositId,
 207 |     |         address indexed depositor,
 208 |     |         uint256 indexed targetChainId,
 209 |     |         address token,
 210 |     |         uint256 amount,
 211 |     |         bytes32 commitment
 212 |     |     );
 213 |     | 
 214 |     |     event WithdrawalInitiated(
 215 |     |         bytes32 indexed withdrawalId,
 216 |     |         address indexed recipient,
 217 |     |         uint256 indexed sourceChainId,
 218 |     |         uint256 amount
 219 |     |     );
 220 |     | 
 221 |     |     event WithdrawalFinalized(
 222 |     |         bytes32 indexed withdrawalId,
 223 |     |         address recipient,
 224 |     |         uint256 amount
 225 |     |     );
 226 |     | 
 227 |     |     event ProofRelayed(
 228 |     |         bytes32 indexed proofHash,
 229 |     |         uint256 indexed sourceChainId,
 230 |     |         bytes32 stateRoot
 231 |     |     );
 232 |     | 
 233 |     |     /*//////////////////////////////////////////////////////////////
 234 |     |                               CUSTOM ERRORS
 235 |     |     //////////////////////////////////////////////////////////////*/
 236 |     | 
 237 |     |     error ChainNotSupported(uint256 chainId);
 238 |     |     error ChainAlreadyConfigured(uint256 chainId);
 239 |     |     error ChainNotEnabled(uint256 chainId);
 240 |     |     error InvalidCommitment(bytes32 commitmentId);
 241 |     |     error CommitmentAlreadyExists(bytes32 commitmentId);
 242 |     |     error CommitmentNotPending(bytes32 commitmentId);
 243 |     |     error ChallengePeriodNotOver(bytes32 commitmentId, uint256 deadline);
 244 |     |     error ChallengePeriodOver(bytes32 commitmentId);
 245 |     |     error InsufficientBond(uint256 provided, uint256 required);
 246 |     |     error NullifierAlreadyUsed(bytes32 nullifier);
 247 |     |     error InvalidProof();
 248 |     |     error DepositNotFound(bytes32 depositId);
 249 |     |     error WithdrawalNotFound(bytes32 withdrawalId);
 250 |     |     error WithdrawalNotFinalized(bytes32 withdrawalId);
 251 |     |     error AlreadyClaimed();
 252 |     |     error RateLimitExceeded();
 253 |     |     error InvalidBlobIndex();
 254 |     |     error ZeroAddress();
 255 |     |     error ZeroAmount();
 256 |     |     error TransferFailed();
 257 |     | 
 258 |     |     /*//////////////////////////////////////////////////////////////
 259 |     |                              CONSTRUCTOR
 260 |     |     //////////////////////////////////////////////////////////////*/
 261 |     | 
 262 |     |     constructor() {
 263 | *   |         _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
 264 | *   |         _grantRole(OPERATOR_ROLE, msg.sender);
 265 | *   |         _grantRole(GUARDIAN_ROLE, msg.sender);
 266 |     | 
 267 | *   |         lastHourReset = block.timestamp;
 268 |     | 
 269 |     |         // Initialize supported L2 chains
 270 |     |         _initializeL2Chains();
 271 |     |     }
 272 |     | 
 273 |     |     /*//////////////////////////////////////////////////////////////
 274 |     |                          L2 CHAIN MANAGEMENT
 275 |     |     //////////////////////////////////////////////////////////////*/
 276 |     | 
 277 |     |     /**
 278 |     |      * @notice Initialize default L2 chain configurations
 279 |     |      */
 280 |     |     function _initializeL2Chains() internal {
 281 |     |         // Arbitrum One
 282 |     |         _configureL2Chain(
 283 | *   |             L2Config({
 284 | *   |                 chainId: 42161,
 285 |     |                 name: "Arbitrum One",
 286 |     |                 rollupType: RollupType.OPTIMISTIC,
 287 |     |                 canonicalBridge: address(0), // Set during deployment
 288 |     |                 messenger: address(0),
 289 |     |                 stateCommitmentChain: address(0),
 290 | *   |                 challengePeriod: 7 days,
 291 |     |                 confirmationBlocks: 1,
 292 |     |                 enabled: true,
 293 | *   |                 gasLimit: 1000000,
 294 |     |                 lastSyncedBlock: 0
 295 |     |             })
 296 |     |         );
 297 |     | 
 298 |     |         // Optimism
 299 |     |         _configureL2Chain(
 300 | *   |             L2Config({
 301 | *   |                 chainId: 10,
 302 |     |                 name: "Optimism",
 303 |     |                 rollupType: RollupType.OPTIMISTIC,
 304 |     |                 canonicalBridge: address(0),
 305 |     |                 messenger: address(0),
 306 |     |                 stateCommitmentChain: address(0),
 307 |     |                 challengePeriod: 7 days,
 308 |     |                 confirmationBlocks: 1,
 309 |     |                 enabled: true,
 310 |     |                 gasLimit: 1000000,
 311 |     |                 lastSyncedBlock: 0
 312 |     |             })
 313 |     |         );
 314 |     | 
 315 |     |         // Base
 316 |     |         _configureL2Chain(
 317 | *   |             L2Config({
 318 | *   |                 chainId: 8453,
 319 |     |                 name: "Base",
 320 |     |                 rollupType: RollupType.OPTIMISTIC,
 321 |     |                 canonicalBridge: address(0),
 322 |     |                 messenger: address(0),
 323 |     |                 stateCommitmentChain: address(0),
 324 |     |                 challengePeriod: 7 days,
 325 |     |                 confirmationBlocks: 1,
 326 |     |                 enabled: true,
 327 |     |                 gasLimit: 1000000,
 328 |     |                 lastSyncedBlock: 0
 329 |     |             })
 330 |     |         );
 331 |     | 
 332 |     |         // zkSync Era
 333 |     |         _configureL2Chain(
 334 | *   |             L2Config({
 335 | *   |                 chainId: 324,
 336 |     |                 name: "zkSync Era",
 337 |     |                 rollupType: RollupType.ZK_ROLLUP,
 338 |     |                 canonicalBridge: address(0),
 339 |     |                 messenger: address(0),
 340 |     |                 stateCommitmentChain: address(0),
 341 |     |                 challengePeriod: 0, // ZK rollups have instant finality
 342 |     |                 confirmationBlocks: 1,
 343 |     |                 enabled: true,
 344 | *   |                 gasLimit: 2000000,
 345 |     |                 lastSyncedBlock: 0
 346 |     |             })
 347 |     |         );
 348 |     | 
 349 |     |         // Scroll
 350 |     |         _configureL2Chain(
 351 | *   |             L2Config({
 352 | *   |                 chainId: 534352,
 353 |     |                 name: "Scroll",
 354 |     |                 rollupType: RollupType.ZK_ROLLUP,
 355 |     |                 canonicalBridge: address(0),
 356 |     |                 messenger: address(0),
 357 |     |                 stateCommitmentChain: address(0),
 358 |     |                 challengePeriod: 0,
 359 |     |                 confirmationBlocks: 1,
 360 |     |                 enabled: true,
 361 | *   |                 gasLimit: 1500000,
 362 |     |                 lastSyncedBlock: 0
 363 |     |             })
 364 |     |         );
 365 |     | 
 366 |     |         // Linea
 367 |     |         _configureL2Chain(
 368 | *   |             L2Config({
 369 | *   |                 chainId: 59144,
 370 |     |                 name: "Linea",
 371 |     |                 rollupType: RollupType.ZK_ROLLUP,
 372 |     |                 canonicalBridge: address(0),
 373 |     |                 messenger: address(0),
 374 |     |                 stateCommitmentChain: address(0),
 375 |     |                 challengePeriod: 0,
 376 |     |                 confirmationBlocks: 1,
 377 |     |                 enabled: true,
 378 |     |                 gasLimit: 1000000,
 379 |     |                 lastSyncedBlock: 0
 380 |     |             })
 381 |     |         );
 382 |     | 
 383 |     |         // Polygon zkEVM
 384 |     |         _configureL2Chain(
 385 | *   |             L2Config({
 386 | *   |                 chainId: 1101,
 387 |     |                 name: "Polygon zkEVM",
 388 |     |                 rollupType: RollupType.ZK_ROLLUP,
 389 |     |                 canonicalBridge: address(0),
 390 |     |                 messenger: address(0),
 391 |     |                 stateCommitmentChain: address(0),
 392 |     |                 challengePeriod: 0,
 393 |     |                 confirmationBlocks: 1,
 394 |     |                 enabled: true,
 395 |     |                 gasLimit: 1000000,
 396 |     |                 lastSyncedBlock: 0
 397 |     |             })
 398 |     |         );
 399 |     |     }
 400 |     | 
 401 |     |     /**
 402 |     |      * @notice Configure an L2 chain
 403 |     |      */
 404 | *   |     function _configureL2Chain(L2Config memory config) internal {
 405 | *   |         l2Configs[config.chainId] = config;
 406 |     |         supportedChainIds.push(config.chainId);
 407 |     | 
 408 | *   |         emit L2ChainConfigured(
 409 |     |             config.chainId,
 410 | *   |             config.name,
 411 |     |             config.rollupType,
 412 |     |             config.canonicalBridge
 413 |     |         );
 414 |     |     }
 415 |     | 
 416 |     |     /**
 417 |     |      * @notice Add or update L2 chain configuration
 418 |     |      * @param config The chain configuration
 419 |     |      */
 420 |     |     function configureL2Chain(
 421 |     |         L2Config calldata config
 422 |     |     ) external onlyRole(OPERATOR_ROLE) {
 423 |     |         if (l2Configs[config.chainId].chainId == 0) {
 424 |     |             supportedChainIds.push(config.chainId);
 425 |     |         }
 426 |     | 
 427 |     |         l2Configs[config.chainId] = config;
 428 |     | 
 429 |     |         emit L2ChainConfigured(
 430 |     |             config.chainId,
 431 |     |             config.name,
 432 |     |             config.rollupType,
 433 |     |             config.canonicalBridge
 434 |     |         );
 435 |     |     }
 436 |     | 
 437 |     |     /**
 438 |     |      * @notice Set canonical bridge address for an L2
 439 |     |      * @param chainId The L2 chain ID
 440 |     |      * @param bridge The canonical bridge address
 441 |     |      */
 442 |     |     function setCanonicalBridge(
 443 |     |         uint256 chainId,
 444 |     |         address bridge
 445 |     |     ) external onlyRole(OPERATOR_ROLE) {
 446 |     |         if (l2Configs[chainId].chainId == 0) revert ChainNotSupported(chainId);
 447 |     |         if (bridge == address(0)) revert ZeroAddress();
 448 |     | 
 449 |     |         l2Configs[chainId].canonicalBridge = bridge;
 450 |     |     }
 451 |     | 
 452 |     |     /**
 453 |     |      * @notice Enable or disable an L2 chain
 454 |     |      * @param chainId The chain ID
 455 |     |      * @param enabled Whether to enable the chain
 456 |     |      */
 457 |     |     function setChainEnabled(
 458 |     |         uint256 chainId,
 459 |     |         bool enabled
 460 |     |     ) external onlyRole(OPERATOR_ROLE) {
 461 | *   |         if (l2Configs[chainId].chainId == 0) revert ChainNotSupported(chainId);
 462 |     | 
 463 |     |         l2Configs[chainId].enabled = enabled;
 464 |     |         emit L2ChainUpdated(chainId, enabled);
 465 |     |     }
 466 |     | 
 467 |     |     /*//////////////////////////////////////////////////////////////
 468 |     |                       STATE COMMITMENT RELAY
 469 |     |     //////////////////////////////////////////////////////////////*/
 470 |     | 
 471 |     |     /**
 472 |     |      * @notice Submit a state commitment from an L2 chain
 473 |     |      * @param sourceChainId The source L2 chain ID
 474 |     |      * @param stateRoot The state root from L2
 475 |     |      * @param proofRoot The Soul proof merkle root
 476 |     |      * @param blockNumber The L2 block number
 477 |     |      */
 478 |     |     function submitStateCommitment(
 479 |     |         uint256 sourceChainId,
 480 |     |         bytes32 stateRoot,
 481 |     |         bytes32 proofRoot,
 482 |     |         uint256 blockNumber
 483 |     |     ) external payable {
 484 |     |         _submitStateCommitment(sourceChainId, stateRoot, proofRoot, blockNumber, bytes32(0));
 485 |     |     }
 486 |     | 
 487 |     |     /**
 488 |     |      * @notice Submit state commitment using EIP-4844 blob
 489 |     |      * @param sourceChainId The source L2 chain ID
 490 |     |      * @param stateRoot The state root from L2
 491 |     |      * @param proofRoot The Soul proof merkle root
 492 |     |      * @param blockNumber The L2 block number
 493 |     |      * @param blobIndex The index of the blob in the current transaction
 494 |     |      */
 495 |     |     function submitStateCommitmentWithBlob(
 496 |     |         uint256 sourceChainId,
 497 |     |         bytes32 stateRoot,
 498 |     |         bytes32 proofRoot,
 499 |     |         uint256 blockNumber,
 500 |     |         uint256 blobIndex
 501 |     |     ) external payable {
 502 |     |         bytes32 blobVersionedHash = _getBlobHash(blobIndex);
 503 |     |         if (blobVersionedHash == bytes32(0)) revert InvalidBlobIndex();
 504 |     |         _submitStateCommitment(sourceChainId, stateRoot, proofRoot, blockNumber, blobVersionedHash);
 505 |     |     }
 506 |     | 
 507 |     |     /**
 508 |     |      * @notice Get blob hash (virtual for testing)
 509 |     |      */
 510 |     |     function _getBlobHash(uint256 index) internal view virtual returns (bytes32 hash) {
 511 |     |         // Placeholder for static analysis baseline
 512 |     |         return bytes32(0);
 513 |     |     }
 514 |     | 
 515 |     |     /**
 516 |     |      * @notice Internal function to handle state commitment submission
 517 |     |      */
 518 |     |     function _submitStateCommitment(
 519 |     |         uint256 sourceChainId,
 520 |     |         bytes32 stateRoot,
 521 |     |         bytes32 proofRoot,
 522 |     |         uint256 blockNumber,
 523 |     |         bytes32 blobVersionedHash
 524 |     |     ) internal nonReentrant whenNotPaused onlyRole(RELAYER_ROLE) {
 525 | *   |         L2Config storage config = l2Configs[sourceChainId];
 526 | *   |         if (config.chainId == 0) revert ChainNotSupported(sourceChainId);
 527 |     |         if (!config.enabled) revert ChainNotEnabled(sourceChainId);
 528 |     |         if (msg.value < minSubmissionBond)
 529 |     |             revert InsufficientBond(msg.value, minSubmissionBond);
 530 |     | 
 531 |     |         // Rate limiting
 532 |     |         _checkRateLimit();
 533 |     | 
 534 |     |         bytes32 commitmentId = keccak256(
 535 |     |             abi.encodePacked(
 536 |     |                 sourceChainId,
 537 |     |                 stateRoot,
 538 |     |                 proofRoot,
 539 |     |                 blockNumber,
 540 |     |                 block.timestamp,
 541 |     |                 blobVersionedHash
 542 |     |             )
 543 |     |         );
 544 |     | 
 545 |     |         if (stateCommitments[commitmentId].commitmentId != bytes32(0)) {
 546 |     |             revert CommitmentAlreadyExists(commitmentId);
 547 |     |         }
 548 |     | 
 549 |     |         uint256 challengeDeadline = config.rollupType == RollupType.ZK_ROLLUP
 550 |     |             ? block.timestamp // ZK rollups finalize immediately
 551 |     |             : block.timestamp + config.challengePeriod;
 552 |     | 
 553 |     |         stateCommitments[commitmentId] = StateCommitment({
 554 |     |             commitmentId: commitmentId,
 555 |     |             sourceChainId: sourceChainId,
 556 |     |             stateRoot: stateRoot,
 557 |     |             proofRoot: proofRoot,
 558 |     |             blockNumber: blockNumber,
 559 |     |             timestamp: block.timestamp,
 560 |     |             status: config.rollupType == RollupType.ZK_ROLLUP
 561 |     |                 ? CommitmentStatus.FINALIZED
 562 |     |                 : CommitmentStatus.PENDING,
 563 |     |             challengeDeadline: challengeDeadline,
 564 |     |             submitter: msg.sender,
 565 |     |             blobVersionedHash: blobVersionedHash
 566 |     |         });
 567 |     | 
 568 |     |         // ZK rollups finalize immediately
 569 |     |         if (config.rollupType == RollupType.ZK_ROLLUP) {
 570 |     |             latestStateRoots[sourceChainId] = stateRoot;
 571 |     |             config.lastSyncedBlock = blockNumber;
 572 |     |         }
 573 |     | 
 574 |     |         totalCommitments++;
 575 |     |         hourlyCommitmentCount++;
 576 |     | 
 577 |     |         emit StateCommitmentSubmitted(
 578 |     |             commitmentId,
 579 |     |             sourceChainId,
 580 |     |             stateRoot,
 581 |     |             msg.sender,
 582 |     |             blobVersionedHash
 583 |     |         );
 584 |     |     }
 585 |     | 
 586 |     |     /**
 587 |     |      * @notice Challenge a pending state commitment (optimistic rollups only)
 588 |     |      * @param commitmentId The commitment to challenge
 589 |     |      * @param reason Challenge reason hash
 590 |     |      */
 591 |     |     function challengeCommitment(
 592 |     |         bytes32 commitmentId,
 593 |     |         bytes32 reason
 594 |     |     ) external nonReentrant {
 595 |     |         StateCommitment storage commitment = stateCommitments[commitmentId];
 596 |     | 
 597 |     |         if (commitment.commitmentId == bytes32(0))
 598 |     |             revert InvalidCommitment(commitmentId);
 599 |     |         if (commitment.status != CommitmentStatus.PENDING)
 600 |     |             revert CommitmentNotPending(commitmentId);
 601 |     |         if (block.timestamp >= commitment.challengeDeadline) {
 602 |     |             revert ChallengePeriodOver(commitmentId);
 603 |     |         }
 604 |     | 
 605 |     |         commitment.status = CommitmentStatus.CHALLENGED;
 606 |     | 
 607 |     |         emit StateCommitmentChallenged(commitmentId, msg.sender, reason);
 608 |     |     }
 609 |     | 
 610 |     |     /**
 611 |     |      * @notice Finalize a state commitment after challenge period
 612 |     |      * @param commitmentId The commitment to finalize
 613 |     |      */
 614 |     |     function finalizeCommitment(bytes32 commitmentId) external nonReentrant {
 615 |     |         StateCommitment storage commitment = stateCommitments[commitmentId];
 616 |     | 
 617 |     |         if (commitment.commitmentId == bytes32(0))
 618 |     |             revert InvalidCommitment(commitmentId);
 619 |     |         if (commitment.status != CommitmentStatus.PENDING)
 620 |     |             revert CommitmentNotPending(commitmentId);
 621 |     |         if (block.timestamp < commitment.challengeDeadline) {
 622 |     |             revert ChallengePeriodNotOver(
 623 |     |                 commitmentId,
 624 |     |                 commitment.challengeDeadline
 625 |     |             );
 626 |     |         }
 627 |     | 
 628 |     |         commitment.status = CommitmentStatus.FINALIZED;
 629 |     |         latestStateRoots[commitment.sourceChainId] = commitment.stateRoot;
 630 |     |         l2Configs[commitment.sourceChainId].lastSyncedBlock = commitment
 631 |     |             .blockNumber;
 632 |     | 
 633 |     |         // Return bond to submitter
 634 |     |         (bool success, ) = payable(commitment.submitter).call{
 635 |     |             value: minSubmissionBond
 636 |     |         }("");
 637 |     |         if (!success) revert TransferFailed();
 638 |     | 
 639 |     |         emit StateCommitmentFinalized(commitmentId, commitment.stateRoot);
 640 |     |     }
 641 |     | 
 642 |     |     /*//////////////////////////////////////////////////////////////
 643 |     |                           DEPOSIT (L1 -> L2)
 644 |     |     //////////////////////////////////////////////////////////////*/
 645 |     | 
 646 |     |     /**
 647 |     |      * @notice Initiate a deposit from L1 to L2 with privacy commitment
 648 |     |      * @param targetChainId The target L2 chain ID
 649 |     |      * @param commitment The Soul commitment for the deposit
 650 |     |      */
 651 |     |     function depositETH(
 652 |     |         uint256 targetChainId,
 653 |     |         bytes32 commitment
 654 |     |     ) external payable nonReentrant whenNotPaused {
 655 |     |         if (msg.value == 0) revert ZeroAmount();
 656 |     |         if (l2Configs[targetChainId].chainId == 0)
 657 |     |             revert ChainNotSupported(targetChainId);
 658 |     |         if (!l2Configs[targetChainId].enabled)
 659 |     |             revert ChainNotEnabled(targetChainId);
 660 |     |         if (commitment == bytes32(0)) revert InvalidCommitment(commitment);
 661 |     | 
 662 |     |         bytes32 depositId = keccak256(
 663 |     |             abi.encodePacked(
 664 |     |                 msg.sender,
 665 |     |                 targetChainId,
 666 |     |                 msg.value,
 667 |     |                 commitment,
 668 |     |                 block.timestamp,
 669 |     |                 totalDeposits
 670 |     |             )
 671 |     |         );
 672 |     | 
 673 |     |         deposits[depositId] = Deposit({
 674 |     |             depositId: depositId,
 675 |     |             depositor: msg.sender,
 676 |     |             targetChainId: targetChainId,
 677 |     |             token: address(0), // ETH
 678 |     |             amount: msg.value,
 679 |     |             commitment: commitment,
 680 |     |             timestamp: block.timestamp,
 681 |     |             claimed: false
 682 |     |         });
 683 |     | 
 684 |     |         totalDeposits++;
 685 |     | 
 686 |     |         emit DepositInitiated(
 687 |     |             depositId,
 688 |     |             msg.sender,
 689 |     |             targetChainId,
 690 |     |             address(0),
 691 |     |             msg.value,
 692 |     |             commitment
 693 |     |         );
 694 |     | 
 695 |     |         // In production: call canonical bridge to relay deposit
 696 |     |         // L2Config storage config = l2Configs[targetChainId];
 697 |     |         // ICanonicalBridge(config.canonicalBridge).depositETH{value: msg.value}(...);
 698 |     |     }
 699 |     | 
 700 |     |     /*//////////////////////////////////////////////////////////////
 701 |     |                         WITHDRAWAL (L2 -> L1)
 702 |     |     //////////////////////////////////////////////////////////////*/
 703 |     | 
 704 |     |     /**
 705 |     |      * @notice Initiate withdrawal claim from L2
 706 |     |      * @param sourceChainId The source L2 chain ID
 707 |     |      * @param amount The withdrawal amount
 708 |     |      * @param nullifier The Soul nullifier to prevent double-spend
 709 |     |      * @param proof Merkle proof from L2 state
 710 |     |      */
 711 |     |     function initiateWithdrawal(
 712 |     |         uint256 sourceChainId,
 713 |     |         uint256 amount,
 714 |     |         bytes32 nullifier,
 715 |     |         bytes32[] calldata proof
 716 |     |     ) external nonReentrant whenNotPaused {
 717 | *   |         if (l2Configs[sourceChainId].chainId == 0)
 718 | *   |             revert ChainNotSupported(sourceChainId);
 719 |     |         if (!l2Configs[sourceChainId].enabled)
 720 |     |             revert ChainNotEnabled(sourceChainId);
 721 |     |         if (usedNullifiers[nullifier]) revert NullifierAlreadyUsed(nullifier);
 722 |     |         if (amount == 0) revert ZeroAmount();
 723 |     | 
 724 |     |         // Verify proof against latest state root
 725 |     |         bytes32 stateRoot = latestStateRoots[sourceChainId];
 726 |     |         if (!_verifyWithdrawalProof(stateRoot, nullifier, amount, proof)) {
 727 |     |             revert InvalidProof();
 728 |     |         }
 729 |     | 
 730 |     |         bytes32 withdrawalId = keccak256(
 731 |     |             abi.encodePacked(
 732 |     |                 msg.sender,
 733 |     |                 sourceChainId,
 734 |     |                 amount,
 735 |     |                 nullifier,
 736 |     |                 block.timestamp
 737 |     |             )
 738 |     |         );
 739 |     | 
 740 |     |         withdrawals[withdrawalId] = Withdrawal({
 741 |     |             withdrawalId: withdrawalId,
 742 |     |             recipient: msg.sender,
 743 |     |             sourceChainId: sourceChainId,
 744 |     |             token: address(0),
 745 |     |             amount: amount,
 746 |     |             nullifier: nullifier,
 747 |     |             proof: proof,
 748 |     |             timestamp: block.timestamp,
 749 |     |             finalized: l2Configs[sourceChainId].rollupType ==
 750 |     |                 RollupType.ZK_ROLLUP,
 751 |     |             claimed: false
 752 |     |         });
 753 |     | 
 754 |     |         usedNullifiers[nullifier] = true;
 755 |     |         totalWithdrawals++;
 756 |     | 
 757 |     |         emit WithdrawalInitiated(
 758 |     |             withdrawalId,
 759 |     |             msg.sender,
 760 |     |             sourceChainId,
 761 |     |             amount
 762 |     |         );
 763 |     |     }
 764 |     | 
 765 |     |     /**
 766 |     |      * @notice Finalize a withdrawal after challenge period (optimistic rollups)
 767 |     |      * @param withdrawalId The withdrawal to finalize
 768 |     |      */
 769 |     |     function finalizeWithdrawal(bytes32 withdrawalId) external nonReentrant {
 770 |     |         Withdrawal storage withdrawal = withdrawals[withdrawalId];
 771 |     | 
 772 |     |         if (withdrawal.withdrawalId == bytes32(0))
 773 |     |             revert WithdrawalNotFound(withdrawalId);
 774 |     |         if (withdrawal.claimed) revert AlreadyClaimed();
 775 |     | 
 776 |     |         L2Config storage config = l2Configs[withdrawal.sourceChainId];
 777 |     | 
 778 |     |         // For optimistic rollups, check challenge period
 779 |     |         if (config.rollupType == RollupType.OPTIMISTIC) {
 780 |     |             if (
 781 |     |                 block.timestamp < withdrawal.timestamp + config.challengePeriod
 782 |     |             ) {
 783 |     |                 revert WithdrawalNotFinalized(withdrawalId);
 784 |     |             }
 785 |     |         }
 786 |     | 
 787 |     |         withdrawal.finalized = true;
 788 |     |     }
 789 |     | 
 790 |     |     /**
 791 |     |      * @notice Claim a finalized withdrawal
 792 |     |      * @param withdrawalId The withdrawal to claim
 793 |     |      */
 794 |     |     function claimWithdrawal(bytes32 withdrawalId) external nonReentrant {
 795 |     |         Withdrawal storage withdrawal = withdrawals[withdrawalId];
 796 |     | 
 797 |     |         if (withdrawal.withdrawalId == bytes32(0))
 798 |     |             revert WithdrawalNotFound(withdrawalId);
 799 |     |         if (!withdrawal.finalized) revert WithdrawalNotFinalized(withdrawalId);
 800 |     |         if (withdrawal.claimed) revert AlreadyClaimed();
 801 |     | 
 802 |     |         withdrawal.claimed = true;
 803 |     | 
 804 |     |         (bool success, ) = payable(withdrawal.recipient).call{
 805 |     |             value: withdrawal.amount
 806 |     |         }("");
 807 |     |         if (!success) revert TransferFailed();
 808 |     | 
 809 |     |         emit WithdrawalFinalized(
 810 |     |             withdrawalId,
 811 |     |             withdrawal.recipient,
 812 |     |             withdrawal.amount
 813 |     |         );
 814 |     |     }
 815 |     | 
 816 |     |     /*//////////////////////////////////////////////////////////////
 817 |     |                           PROOF RELAY
 818 |     |     //////////////////////////////////////////////////////////////*/
 819 |     | 
 820 |     |     /**
 821 |     |      * @notice Relay a Soul proof from L2 to L1
 822 |     |      * @param sourceChainId The source L2 chain
 823 |     |      * @param proofHash The proof hash
 824 |     |      * @param stateRoot The state root the proof is against
 825 |     |      */
 826 |     |     function relayProof(
 827 |     |         uint256 sourceChainId,
 828 |     |         bytes32 proofHash,
 829 |     |         bytes32 stateRoot,
 830 |     |         bytes calldata /* proofData */
 831 |     |     ) external nonReentrant whenNotPaused onlyRole(RELAYER_ROLE) {
 832 |     |         if (l2Configs[sourceChainId].chainId == 0)
 833 |     |             revert ChainNotSupported(sourceChainId);
 834 |     |         if (relayedProofs[proofHash]) revert InvalidProof();
 835 |     | 
 836 |     |         // Verify the state root is valid
 837 |     |         if (latestStateRoots[sourceChainId] != stateRoot) {
 838 |     |             revert InvalidProof();
 839 |     |         }
 840 |     | 
 841 |     |         relayedProofs[proofHash] = true;
 842 |     | 
 843 |     |         emit ProofRelayed(proofHash, sourceChainId, stateRoot);
 844 |     |     }
 845 |     | 
 846 |     |     /*//////////////////////////////////////////////////////////////
 847 |     |                            INTERNAL FUNCTIONS
 848 |     |     //////////////////////////////////////////////////////////////*/
 849 |     | 
 850 |     |     /**
 851 |     |      * @notice Check rate limit
 852 |     |      */
 853 |     |     function _checkRateLimit() internal {
 854 |     |         if (block.timestamp >= lastHourReset + 1 hours) {
 855 |     |             hourlyCommitmentCount = 0;
 856 |     |             lastHourReset = block.timestamp;
 857 |     |         }
 858 |     | 
 859 |     |         if (hourlyCommitmentCount >= maxCommitmentsPerHour) {
 860 |     |             revert RateLimitExceeded();
 861 |     |         }
 862 |     |     }
 863 |     | 
 864 |     |     /**
 865 |     |      * @notice Verify withdrawal proof (placeholder - implement with actual Merkle verification)
 866 |     |      */
 867 |     |     function _verifyWithdrawalProof(
 868 |     |         bytes32 stateRoot,
 869 |     |         bytes32 nullifier,
 870 |     |         uint256 amount,
 871 |     |         bytes32[] calldata proof
 872 |     |     ) internal pure returns (bool) {
 873 |     |         // In production: implement proper Merkle proof verification
 874 |     |         // This is a placeholder that should be replaced with actual verification
 875 |     |         if (stateRoot == bytes32(0)) return false;
 876 |     |         if (proof.length == 0) return false;
 877 |     | 
 878 |     |         // Compute leaf hash
 879 |     |         bytes32 leaf = keccak256(abi.encodePacked(nullifier, amount));
 880 |     | 
 881 |     |         // Verify Merkle proof
 882 |     |         bytes32 computedRoot = leaf;
 883 |     |         for (uint256 i = 0; i < proof.length; i++) {
 884 |     |             bytes32 proofElement = proof[i];
 885 |     |             if (computedRoot <= proofElement) {
 886 |     |                 computedRoot = keccak256(
 887 |     |                     abi.encodePacked(computedRoot, proofElement)
 888 |     |                 );
 889 |     |             } else {
 890 |     |                 computedRoot = keccak256(
 891 |     |                     abi.encodePacked(proofElement, computedRoot)
 892 |     |                 );
 893 |     |             }
 894 |     |         }
 895 |     | 
 896 |     |         return computedRoot == stateRoot;
 897 |     |     }
 898 |     | 
 899 |     |     /*//////////////////////////////////////////////////////////////
 900 |     |                            VIEW FUNCTIONS
 901 |     |     //////////////////////////////////////////////////////////////*/
 902 |     | 
 903 |     |     /**
 904 |     |      * @notice Get supported chain IDs
 905 |     |      */
 906 |     |     function getSupportedChainIds() external view returns (uint256[] memory) {
 907 |     |         return supportedChainIds;
 908 |     |     }
 909 |     | 
 910 |     |     /**
 911 |     |      * @notice Get L2 chain configuration
 912 |     |      */
 913 |     |     function getL2Config(
 914 |     |         uint256 chainId
 915 |     |     ) external view returns (L2Config memory) {
 916 |     |         return l2Configs[chainId];
 917 |     |     }
 918 |     | 
 919 |     |     /**
 920 |     |      * @notice Check if a chain is supported
 921 |     |      */
 922 |     |     function isChainSupported(uint256 chainId) external view returns (bool) {
 923 |     |         return l2Configs[chainId].chainId != 0 && l2Configs[chainId].enabled;
 924 |     |     }
 925 |     | 
 926 |     |     /**
 927 |     |      * @notice Get latest state root for a chain
 928 |     |      */
 929 |     |     function getLatestStateRoot(
 930 |     |         uint256 chainId
 931 |     |     ) external view returns (bytes32) {
 932 |     |         return latestStateRoots[chainId];
 933 |     |     }
 934 |     | 
 935 |     |     /**
 936 |     |      * @notice Check if a nullifier has been used
 937 |     |      */
 938 |     |     function isNullifierUsed(bytes32 nullifier) external view returns (bool) {
 939 |     |         return usedNullifiers[nullifier];
 940 |     |     }
 941 |     | 
 942 |     |     /*//////////////////////////////////////////////////////////////
 943 |     |                            ADMIN FUNCTIONS
 944 |     |     //////////////////////////////////////////////////////////////*/
 945 |     | 
 946 |     |     /**
 947 |     |      * @notice Set rate limit parameters
 948 |     |      */
 949 |     |     function setRateLimits(
 950 |     |         uint256 _maxCommitmentsPerHour
 951 |     |     ) external onlyRole(OPERATOR_ROLE) {
 952 |     |         maxCommitmentsPerHour = _maxCommitmentsPerHour;
 953 |     |     }
 954 |     | 
 955 |     |     /**
 956 |     |      * @notice Set minimum submission bond
 957 |     |      */
 958 |     |     function setMinSubmissionBond(
 959 |     |         uint256 _minBond
 960 |     |     ) external onlyRole(OPERATOR_ROLE) {
 961 |     |         minSubmissionBond = _minBond;
 962 |     |     }
 963 |     | 
 964 |     |     /**
 965 |     |      * @notice Set maximum commitments per hour
 966 |     |      */
 967 |     |     function setMaxCommitmentsPerHour(
 968 |     |         uint256 _maxCommitments
 969 |     |     ) external onlyRole(OPERATOR_ROLE) {
 970 | *   |         maxCommitmentsPerHour = _maxCommitments;
 971 |     |     }
 972 |     | 
 973 |     |     /**
 974 |     |      * @notice Pause the contract
 975 |     |      */
 976 |     |     function pause() external onlyRole(GUARDIAN_ROLE) {
 977 |     |         _pause();
 978 |     |     }
 979 |     | 
 980 |     |     /**
 981 |     |      * @notice Unpause the contract
 982 |     |      */
 983 |     |     function unpause() external onlyRole(OPERATOR_ROLE) {
 984 |     |         _unpause();
 985 |     |     }
 986 |     | 
 987 |     |     /**
 988 |     |      * @notice Receive ETH for deposits
 989 |     |      */
 990 |     |     receive() external payable {}
 991 |     | }
 992 |     | 

/Users/manishghimire/Downloads/Soul Protocol/node_modules/@openzeppelin/contracts/access/AccessControl.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.4.0) (access/AccessControl.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IAccessControl} from "./IAccessControl.sol";
   7 |     | import {Context} from "../utils/Context.sol";
   8 |     | import {IERC165, ERC165} from "../utils/introspection/ERC165.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Contract module that allows children to implement role-based access
  12 |     |  * control mechanisms. This is a lightweight version that doesn't allow enumerating role
  13 |     |  * members except through off-chain means by accessing the contract event logs. Some
  14 |     |  * applications may benefit from on-chain enumerability, for those cases see
  15 |     |  * {AccessControlEnumerable}.
  16 |     |  *
  17 |     |  * Roles are referred to by their `bytes32` identifier. These should be exposed
  18 |     |  * in the external API and be unique. The best way to achieve this is by
  19 |     |  * using `public constant` hash digests:
  20 |     |  *
  21 |     |  * ```solidity
  22 |     |  * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
  23 |     |  * ```
  24 |     |  *
  25 |     |  * Roles can be used to represent a set of permissions. To restrict access to a
  26 |     |  * function call, use {hasRole}:
  27 |     |  *
  28 |     |  * ```solidity
  29 |     |  * function foo() public {
  30 |     |  *     require(hasRole(MY_ROLE, msg.sender));
  31 |     |  *     ...
  32 |     |  * }
  33 |     |  * ```
  34 |     |  *
  35 |     |  * Roles can be granted and revoked dynamically via the {grantRole} and
  36 |     |  * {revokeRole} functions. Each role has an associated admin role, and only
  37 |     |  * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
  38 |     |  *
  39 |     |  * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
  40 |     |  * that only accounts with this role will be able to grant or revoke other
  41 |     |  * roles. More complex role relationships can be created by using
  42 |     |  * {_setRoleAdmin}.
  43 |     |  *
  44 |     |  * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
  45 |     |  * grant and revoke this role. Extra precautions should be taken to secure
  46 |     |  * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}
  47 |     |  * to enforce additional security measures for this role.
  48 |     |  */
  49 |     | abstract contract AccessControl is Context, IAccessControl, ERC165 {
  50 |     |     struct RoleData {
  51 |     |         mapping(address account => bool) hasRole;
  52 |     |         bytes32 adminRole;
  53 |     |     }
  54 |     | 
  55 |     |     mapping(bytes32 role => RoleData) private _roles;
  56 |     | 
  57 | *   |     bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Modifier that checks that an account has a specific role. Reverts
  61 |     |      * with an {AccessControlUnauthorizedAccount} error including the required role.
  62 |     |      */
  63 |     |     modifier onlyRole(bytes32 role) {
  64 | *   |         _checkRole(role);
  65 |     |         _;
  66 |     |     }
  67 |     | 
  68 |     |     /// @inheritdoc IERC165
  69 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
  70 |     |         return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
  71 |     |     }
  72 |     | 
  73 |     |     /**
  74 |     |      * @dev Returns `true` if `account` has been granted `role`.
  75 |     |      */
  76 |     |     function hasRole(bytes32 role, address account) public view virtual returns (bool) {
  77 | *   |         return _roles[role].hasRole[account];
  78 |     |     }
  79 |     | 
  80 |     |     /**
  81 |     |      * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`
  82 |     |      * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.
  83 |     |      */
  84 | *   |     function _checkRole(bytes32 role) internal view virtual {
  85 |     |         _checkRole(role, _msgSender());
  86 |     |     }
  87 |     | 
  88 |     |     /**
  89 |     |      * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`
  90 |     |      * is missing `role`.
  91 |     |      */
  92 |     |     function _checkRole(bytes32 role, address account) internal view virtual {
  93 | *   |         if (!hasRole(role, account)) {
  94 |     |             revert AccessControlUnauthorizedAccount(account, role);
  95 |     |         }
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
 100 |     |      * {revokeRole}.
 101 |     |      *
 102 |     |      * To change a role's admin, use {_setRoleAdmin}.
 103 |     |      */
 104 |     |     function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {
 105 | *   |         return _roles[role].adminRole;
 106 |     |     }
 107 |     | 
 108 |     |     /**
 109 |     |      * @dev Grants `role` to `account`.
 110 |     |      *
 111 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
 112 |     |      * event.
 113 |     |      *
 114 |     |      * Requirements:
 115 |     |      *
 116 |     |      * - the caller must have ``role``'s admin role.
 117 |     |      *
 118 |     |      * May emit a {RoleGranted} event.
 119 |     |      */
 120 |     |     function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
 121 | *   |         _grantRole(role, account);
 122 |     |     }
 123 |     | 
 124 |     |     /**
 125 |     |      * @dev Revokes `role` from `account`.
 126 |     |      *
 127 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
 128 |     |      *
 129 |     |      * Requirements:
 130 |     |      *
 131 |     |      * - the caller must have ``role``'s admin role.
 132 |     |      *
 133 |     |      * May emit a {RoleRevoked} event.
 134 |     |      */
 135 |     |     function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
 136 |     |         _revokeRole(role, account);
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Revokes `role` from the calling account.
 141 |     |      *
 142 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
 143 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
 144 |     |      * if they are compromised (such as when a trusted device is misplaced).
 145 |     |      *
 146 |     |      * If the calling account had been revoked `role`, emits a {RoleRevoked}
 147 |     |      * event.
 148 |     |      *
 149 |     |      * Requirements:
 150 |     |      *
 151 |     |      * - the caller must be `callerConfirmation`.
 152 |     |      *
 153 |     |      * May emit a {RoleRevoked} event.
 154 |     |      */
 155 |     |     function renounceRole(bytes32 role, address callerConfirmation) public virtual {
 156 |     |         if (callerConfirmation != _msgSender()) {
 157 |     |             revert AccessControlBadConfirmation();
 158 |     |         }
 159 |     | 
 160 |     |         _revokeRole(role, callerConfirmation);
 161 |     |     }
 162 |     | 
 163 |     |     /**
 164 |     |      * @dev Sets `adminRole` as ``role``'s admin role.
 165 |     |      *
 166 |     |      * Emits a {RoleAdminChanged} event.
 167 |     |      */
 168 |     |     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
 169 |     |         bytes32 previousAdminRole = getRoleAdmin(role);
 170 |     |         _roles[role].adminRole = adminRole;
 171 |     |         emit RoleAdminChanged(role, previousAdminRole, adminRole);
 172 |     |     }
 173 |     | 
 174 |     |     /**
 175 |     |      * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.
 176 |     |      *
 177 |     |      * Internal function without access restriction.
 178 |     |      *
 179 |     |      * May emit a {RoleGranted} event.
 180 |     |      */
 181 | *   |     function _grantRole(bytes32 role, address account) internal virtual returns (bool) {
 182 | *   |         if (!hasRole(role, account)) {
 183 | *   |             _roles[role].hasRole[account] = true;
 184 | *   |             emit RoleGranted(role, account, _msgSender());
 185 | *   |             return true;
 186 |     |         } else {
 187 | *   |             return false;
 188 |     |         }
 189 |     |     }
 190 |     | 
 191 |     |     /**
 192 |     |      * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.
 193 |     |      *
 194 |     |      * Internal function without access restriction.
 195 |     |      *
 196 |     |      * May emit a {RoleRevoked} event.
 197 |     |      */
 198 |     |     function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {
 199 |     |         if (hasRole(role, account)) {
 200 |     |             _roles[role].hasRole[account] = false;
 201 |     |             emit RoleRevoked(role, account, _msgSender());
 202 |     |             return true;
 203 |     |         } else {
 204 |     |             return false;
 205 |     |         }
 206 |     |     }
 207 |     | }
 208 |     | 

/Users/manishghimire/Downloads/Soul Protocol/node_modules/@openzeppelin/contracts/access/IAccessControl.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.4.0) (access/IAccessControl.sol)
   3 |     | 
   4 |     | pragma solidity >=0.8.4;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev External interface of AccessControl declared to support ERC-165 detection.
   8 |     |  */
   9 |     | interface IAccessControl {
  10 |     |     /**
  11 |     |      * @dev The `account` is missing a role.
  12 |     |      */
  13 |     |     error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
  14 |     | 
  15 |     |     /**
  16 |     |      * @dev The caller of a function is not the expected one.
  17 |     |      *
  18 |     |      * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.
  19 |     |      */
  20 |     |     error AccessControlBadConfirmation();
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
  24 |     |      *
  25 |     |      * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
  26 |     |      * {RoleAdminChanged} not being emitted to signal this.
  27 |     |      */
  28 |     |     event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Emitted when `account` is granted `role`.
  32 |     |      *
  33 |     |      * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).
  34 |     |      * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.
  35 |     |      */
  36 |     |     event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Emitted when `account` is revoked `role`.
  40 |     |      *
  41 |     |      * `sender` is the account that originated the contract call:
  42 |     |      *   - if using `revokeRole`, it is the admin role bearer
  43 |     |      *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
  44 |     |      */
  45 |     |     event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
  46 |     | 
  47 |     |     /**
  48 |     |      * @dev Returns `true` if `account` has been granted `role`.
  49 |     |      */
  50 |     |     function hasRole(bytes32 role, address account) external view returns (bool);
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
  54 |     |      * {revokeRole}.
  55 |     |      *
  56 |     |      * To change a role's admin, use {AccessControl-_setRoleAdmin}.
  57 |     |      */
  58 |     |     function getRoleAdmin(bytes32 role) external view returns (bytes32);
  59 |     | 
  60 |     |     /**
  61 |     |      * @dev Grants `role` to `account`.
  62 |     |      *
  63 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
  64 |     |      * event.
  65 |     |      *
  66 |     |      * Requirements:
  67 |     |      *
  68 |     |      * - the caller must have ``role``'s admin role.
  69 |     |      */
  70 |     |     function grantRole(bytes32 role, address account) external;
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Revokes `role` from `account`.
  74 |     |      *
  75 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
  76 |     |      *
  77 |     |      * Requirements:
  78 |     |      *
  79 |     |      * - the caller must have ``role``'s admin role.
  80 |     |      */
  81 |     |     function revokeRole(bytes32 role, address account) external;
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Revokes `role` from the calling account.
  85 |     |      *
  86 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
  87 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
  88 |     |      * if they are compromised (such as when a trusted device is misplaced).
  89 |     |      *
  90 |     |      * If the calling account had been granted `role`, emits a {RoleRevoked}
  91 |     |      * event.
  92 |     |      *
  93 |     |      * Requirements:
  94 |     |      *
  95 |     |      * - the caller must be `callerConfirmation`.
  96 |     |      */
  97 |     |     function renounceRole(bytes32 role, address callerConfirmation) external;
  98 |     | }
  99 |     | 

/Users/manishghimire/Downloads/Soul Protocol/node_modules/@openzeppelin/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 |     |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | 
 25 |     |     function _contextSuffixLength() internal view virtual returns (uint256) {
 26 |     |         return 0;
 27 |     |     }
 28 |     | }
 29 |     | 

/Users/manishghimire/Downloads/Soul Protocol/node_modules/@openzeppelin/contracts/utils/Pausable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {Context} from "../utils/Context.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Contract module which allows children to implement an emergency stop
  10 |     |  * mechanism that can be triggered by an authorized account.
  11 |     |  *
  12 |     |  * This module is used through inheritance. It will make available the
  13 |     |  * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
  14 |     |  * the functions of your contract. Note that they will not be pausable by
  15 |     |  * simply including this module, only once the modifiers are put in place.
  16 |     |  */
  17 |     | abstract contract Pausable is Context {
  18 |     |     bool private _paused;
  19 |     | 
  20 |     |     /**
  21 |     |      * @dev Emitted when the pause is triggered by `account`.
  22 |     |      */
  23 |     |     event Paused(address account);
  24 |     | 
  25 |     |     /**
  26 |     |      * @dev Emitted when the pause is lifted by `account`.
  27 |     |      */
  28 |     |     event Unpaused(address account);
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev The operation failed because the contract is paused.
  32 |     |      */
  33 |     |     error EnforcedPause();
  34 |     | 
  35 |     |     /**
  36 |     |      * @dev The operation failed because the contract is not paused.
  37 |     |      */
  38 |     |     error ExpectedPause();
  39 |     | 
  40 |     |     /**
  41 |     |      * @dev Modifier to make a function callable only when the contract is not paused.
  42 |     |      *
  43 |     |      * Requirements:
  44 |     |      *
  45 |     |      * - The contract must not be paused.
  46 |     |      */
  47 | *   |     modifier whenNotPaused() {
  48 |     |         _requireNotPaused();
  49 |     |         _;
  50 |     |     }
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev Modifier to make a function callable only when the contract is paused.
  54 |     |      *
  55 |     |      * Requirements:
  56 |     |      *
  57 |     |      * - The contract must be paused.
  58 |     |      */
  59 |     |     modifier whenPaused() {
  60 |     |         _requirePaused();
  61 |     |         _;
  62 |     |     }
  63 |     | 
  64 |     |     /**
  65 |     |      * @dev Returns true if the contract is paused, and false otherwise.
  66 |     |      */
  67 |     |     function paused() public view virtual returns (bool) {
  68 | *   |         return _paused;
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Throws if the contract is paused.
  73 |     |      */
  74 | *   |     function _requireNotPaused() internal view virtual {
  75 | *   |         if (paused()) {
  76 |     |             revert EnforcedPause();
  77 |     |         }
  78 |     |     }
  79 |     | 
  80 |     |     /**
  81 |     |      * @dev Throws if the contract is not paused.
  82 |     |      */
  83 |     |     function _requirePaused() internal view virtual {
  84 |     |         if (!paused()) {
  85 |     |             revert ExpectedPause();
  86 |     |         }
  87 |     |     }
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Triggers stopped state.
  91 |     |      *
  92 |     |      * Requirements:
  93 |     |      *
  94 |     |      * - The contract must not be paused.
  95 |     |      */
  96 |     |     function _pause() internal virtual whenNotPaused {
  97 |     |         _paused = true;
  98 |     |         emit Paused(_msgSender());
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev Returns to normal state.
 103 |     |      *
 104 |     |      * Requirements:
 105 |     |      *
 106 |     |      * - The contract must be paused.
 107 |     |      */
 108 |     |     function _unpause() internal virtual whenPaused {
 109 |     |         _paused = false;
 110 |     |         emit Unpaused(_msgSender());
 111 |     |     }
 112 |     | }
 113 |     | 

/Users/manishghimire/Downloads/Soul Protocol/node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Contract module that helps prevent reentrant calls to a function.
  8 |     |  *
  9 |     |  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 10 |     |  * available, which can be applied to functions to make sure there are no nested
 11 |     |  * (reentrant) calls to them.
 12 |     |  *
 13 |     |  * Note that because there is a single `nonReentrant` guard, functions marked as
 14 |     |  * `nonReentrant` may not call one another. This can be worked around by making
 15 |     |  * those functions `private`, and then adding `external` `nonReentrant` entry
 16 |     |  * points to them.
 17 |     |  *
 18 |     |  * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,
 19 |     |  * consider using {ReentrancyGuardTransient} instead.
 20 |     |  *
 21 |     |  * TIP: If you would like to learn more about reentrancy and alternative ways
 22 |     |  * to protect against it, check out our blog post
 23 |     |  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 24 |     |  */
 25 |     | abstract contract ReentrancyGuard {
 26 |     |     // Booleans are more expensive than uint256 or any type that takes up a full
 27 |     |     // word because each write operation emits an extra SLOAD to first read the
 28 |     |     // slot's contents, replace the bits taken up by the boolean, and then write
 29 |     |     // back. This is the compiler's defense against contract upgrades and
 30 |     |     // pointer aliasing, and it cannot be disabled.
 31 |     | 
 32 |     |     // The values being non-zero value makes deployment a bit more expensive,
 33 |     |     // but in exchange the refund on every call to nonReentrant will be lower in
 34 |     |     // amount. Since refunds are capped to a percentage of the total
 35 |     |     // transaction's gas, it is best to keep them low in cases like this one, to
 36 |     |     // increase the likelihood of the full refund coming into effect.
 37 | *   |     uint256 private constant NOT_ENTERED = 1;
 38 | *   |     uint256 private constant ENTERED = 2;
 39 |     | 
 40 |     |     uint256 private _status;
 41 |     | 
 42 |     |     /**
 43 |     |      * @dev Unauthorized reentrant call.
 44 |     |      */
 45 |     |     error ReentrancyGuardReentrantCall();
 46 |     | 
 47 |     |     constructor() {
 48 |     |         _status = NOT_ENTERED;
 49 |     |     }
 50 |     | 
 51 |     |     /**
 52 |     |      * @dev Prevents a contract from calling itself, directly or indirectly.
 53 |     |      * Calling a `nonReentrant` function from another `nonReentrant`
 54 |     |      * function is not supported. It is possible to prevent this from happening
 55 |     |      * by making the `nonReentrant` function external, and making it call a
 56 |     |      * `private` function that does the actual work.
 57 |     |      */
 58 | *   |     modifier nonReentrant() {
 59 |     |         _nonReentrantBefore();
 60 |     |         _;
 61 |     |         _nonReentrantAfter();
 62 |     |     }
 63 |     | 
 64 | *   |     function _nonReentrantBefore() private {
 65 |     |         // On the first call to nonReentrant, _status will be NOT_ENTERED
 66 | *   |         if (_status == ENTERED) {
 67 |     |             revert ReentrancyGuardReentrantCall();
 68 |     |         }
 69 |     | 
 70 |     |         // Any calls to nonReentrant after this point will fail
 71 |     |         _status = ENTERED;
 72 |     |     }
 73 |     | 
 74 |     |     function _nonReentrantAfter() private {
 75 |     |         // By storing the original value once again, a refund is triggered (see
 76 |     |         // https://eips.ethereum.org/EIPS/eip-2200)
 77 |     |         _status = NOT_ENTERED;
 78 |     |     }
 79 |     | 
 80 |     |     /**
 81 |     |      * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
 82 |     |      * `nonReentrant` function in the call stack.
 83 |     |      */
 84 |     |     function _reentrancyGuardEntered() internal view returns (bool) {
 85 |     |         return _status == ENTERED;
 86 |     |     }
 87 |     | }
 88 |     | 

/Users/manishghimire/Downloads/Soul Protocol/node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC165} from "./IERC165.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Implementation of the {IERC165} interface.
 10 |     |  *
 11 |     |  * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check
 12 |     |  * for the additional interface id that will be supported. For example:
 13 |     |  *
 14 |     |  * ```solidity
 15 |     |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 16 |     |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 17 |     |  * }
 18 |     |  * ```
 19 |     |  */
 20 |     | abstract contract ERC165 is IERC165 {
 21 |     |     /// @inheritdoc IERC165
 22 |     |     function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
 23 |     |         return interfaceId == type(IERC165).interfaceId;
 24 |     |     }
 25 |     | }
 26 |     | 

/Users/manishghimire/Downloads/Soul Protocol/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity >=0.4.16;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC-165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[ERC].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165 {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/Users/manishghimire/Downloads/Soul Protocol/test/fuzz/BridgeFuzz.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import "../../contracts/crosschain/EthereumL1Bridge.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title BridgeFuzz
  8 |     |  * @notice Echidna fuzzing target for EthereumL1Bridge
  9 |     |  */
 10 | *r  | contract BridgeFuzz {
 11 |     |     EthereumL1Bridge public bridge;
 12 |     |     
 13 |     |     // Track consistency
 14 | *   |     uint256 public totalDeposited;
 15 | *   |     uint256 public totalWithdrawn;
 16 |     |     
 17 |     |     constructor() payable {
 18 | *   |         bridge = new EthereumL1Bridge();
 19 |     |         
 20 |     |         // Grant roles to this contract for fuzzing
 21 | *   |         bridge.grantRole(bridge.DEFAULT_ADMIN_ROLE(), address(this));
 22 | *   |         bridge.grantRole(keccak256("RELAYER_ROLE"), address(this));
 23 | *   |         bridge.grantRole(keccak256("OPERATOR_ROLE"), address(this));
 24 |     |         
 25 |     |         // Initial setup
 26 | *   |         bridge.setMaxCommitmentsPerHour(10);
 27 |     |     }
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Invariant: hourlyCommitmentCount should never exceed maxCommitmentsPerHour
 31 |     |      * Note: This might be violated if time is warped by Echidna, but let's check.
 32 |     |      */
 33 |     |     function echidna_rate_limit_protected() public view returns (bool) {
 34 | *   |         return bridge.hourlyCommitmentCount() <= bridge.maxCommitmentsPerHour();
 35 |     |     }
 36 |     | 
 37 |     |     /**
 38 |     |      * @dev Invariant: withdrawalId should be unique and nullifiers should not be reused
 39 |     |      */
 40 |     |     function echidna_no_double_withdrawal() public view returns (bool) {
 41 |     |         // This is hard to check globally in Echidna without external state, 
 42 |     |         // but we can check if totalWithdrawals increments correctly.
 43 |     |         return true; 
 44 |     |     }
 45 |     | 
 46 |     |     // Fuzzing entry points
 47 |     |     
 48 |     |     function submitCommitment(uint256 chainId, bytes32 stateRoot, bytes32 proofRoot, uint256 blockNum) public payable {
 49 |     |         // Echidna will try different values
 50 | *   |         (bool success, ) = address(bridge).call{value: msg.value}(
 51 | *   |             abi.encodeWithSelector(bridge.submitStateCommitment.selector, chainId, stateRoot, proofRoot, blockNum)
 52 |     |         );
 53 |     |     }
 54 |     |     
 55 |     |     function initiateWithdrawal(uint256 chainId, uint256 amount, bytes32 nullifier, bytes32[] calldata proof) public {
 56 | *   |         (bool success, ) = address(bridge).call(
 57 | *   |             abi.encodeWithSelector(bridge.initiateWithdrawal.selector, chainId, amount, nullifier, proof)
 58 |     |         );
 59 | *   |         if (success) {
 60 |     |             totalWithdrawn += amount;
 61 |     |         }
 62 |     |     }
 63 |     |     
 64 |     |     function setMaxLimit(uint256 newLimit) public {
 65 | *   |         bridge.setMaxCommitmentsPerHour(newLimit);
 66 |     |     }
 67 |     | }
 68 |     | 

