# Extended Privacy Fuzz Campaign Configuration
# Run: forge test --match-path "test/fuzz/Privacy*" --fuzz-runs 1000000

[profile.privacy-extended]
# Extended fuzzing for privacy-critical functions
fuzz = { runs = 1000000, max_test_rejects = 500000 }
invariant = { runs = 50000, depth = 100 }

# ============================================================================
# CAMPAIGN: STEALTH ADDRESSES
# Target: 1M iterations over 24 hours
# ============================================================================

[campaign.stealth-addresses]
name = "Stealth Address Fuzz Campaign"
runs = 1000000
timeout = 86400  # 24 hours
target = "test/fuzz/StealthAddressFuzz.t.sol"

[campaign.stealth-addresses.mutations]
viewTag = { type = "uint8", range = [0, 255] }
ephemeralKey = { type = "bytes32", strategy = "random" }
spendingPubKeyX = { type = "uint256", strategy = "random" }
spendingPubKeyY = { type = "uint256", strategy = "random" }
viewingPubKeyX = { type = "uint256", strategy = "random" }
viewingPubKeyY = { type = "uint256", strategy = "random" }
recipient = { type = "address", strategy = "random" }

[campaign.stealth-addresses.properties]
determinism = "Same inputs always produce same stealth address"
unlinkability = "Different ephemeral keys produce different addresses"
view_tag_coverage = "All 256 view tag values tested"

# ============================================================================
# CAMPAIGN: RING CONFIDENTIAL TRANSACTIONS
# Target: 500K iterations over 48 hours
# ============================================================================

[campaign.ring-ct]
name = "RingCT Fuzz Campaign"
runs = 500000
timeout = 172800  # 48 hours
target = "test/fuzz/RingCTFuzz.t.sol"

[campaign.ring-ct.mutations]
ringSize = { type = "uint8", range = [2, 16] }
inputAmounts = { type = "uint256[]", length = [1, 4], max_value = "1e18" }
outputAmounts = { type = "uint256[]", length = [1, 4], max_value = "1e18" }
blindingFactors = { type = "bytes32[]", length = [1, 8], strategy = "random" }
keyImages = { type = "bytes32[]", length = [1, 4], strategy = "unique" }
decoyIndices = { type = "uint8[]", length = [1, 16], range = [0, 15] }

[campaign.ring-ct.properties]
balance_conservation = "Sum of inputs equals sum of outputs plus fee"
key_image_uniqueness = "Each key image is unique per transaction"
ring_anonymity = "Signer index cannot be determined"
range_proof_soundness = "All amounts fit in 64 bits"

# ============================================================================
# CAMPAIGN: NULLIFIERS
# Target: 2M iterations over 24 hours
# ============================================================================

[campaign.nullifiers]
name = "Nullifier Fuzz Campaign"
runs = 2000000
timeout = 86400  # 24 hours
target = "test/fuzz/NullifierFuzz.t.sol"

[campaign.nullifiers.mutations]
secret = { type = "bytes32", strategy = "random" }
commitment = { type = "bytes32", strategy = "random" }
sourceDomain = { type = "uint256", range = [1, 10000] }
targetDomain = { type = "uint256", range = [1, 10000] }
epochId = { type = "uint256", range = [1, 1000000] }
appId = { type = "bytes32", strategy = "random" }

[campaign.nullifiers.properties]
determinism = "Same inputs produce same nullifier"
uniqueness = "Different secrets produce different nullifiers"
domain_isolation = "Nullifiers are domain-specific"
cross_domain_asymmetry = "A→B ≠ B→A nullifiers"
pil_binding_determinism = "PIL binding is deterministic"

# ============================================================================
# CAMPAIGN: HOMOMORPHIC COMMITMENTS
# Target: 500K iterations over 24 hours
# ============================================================================

[campaign.homomorphic]
name = "Homomorphic Commitment Fuzz Campaign"
runs = 500000
timeout = 86400  # 24 hours
target = "test/fuzz/HomomorphicFuzz.t.sol"

[campaign.homomorphic.mutations]
value1 = { type = "uint256", max_value = "1e18" }
value2 = { type = "uint256", max_value = "1e18" }
blinding1 = { type = "bytes32", strategy = "random" }
blinding2 = { type = "bytes32", strategy = "random" }

[campaign.homomorphic.properties]
additivity = "C(v1) + C(v2) = C(v1+v2) with combined blinding"
determinism = "Same inputs produce same commitment"
binding = "Cannot open to different values"
hiding = "Commitment reveals nothing about value"

# ============================================================================
# CAMPAIGN: PRIVATE RELAYER NETWORK
# Target: 250K iterations over 12 hours
# ============================================================================

[campaign.relayer-network]
name = "Private Relayer Network Fuzz Campaign"
runs = 250000
timeout = 43200  # 12 hours
target = "test/fuzz/RelayerNetworkFuzz.t.sol"

[campaign.relayer-network.mutations]
relayerStake = { type = "uint256", range = ["1e18", "100e18"] }
relayerCount = { type = "uint8", range = [1, 50] }
feeAmount = { type = "uint256", range = [0, "1e16"] }
commitHash = { type = "bytes32", strategy = "random" }
revealDelay = { type = "uint256", range = [1, 100] }

[campaign.relayer-network.properties]
mev_protection = "Commit-reveal prevents front-running"
stake_requirement = "Only staked relayers can relay"
fee_bounds = "Fees within configured limits"
reputation_tracking = "Successful relays improve reputation"

# ============================================================================
# CAMPAIGN: RECURSIVE PROOF AGGREGATION
# Target: 100K iterations over 12 hours
# ============================================================================

[campaign.recursive-proofs]
name = "Recursive Proof Aggregation Fuzz Campaign"
runs = 100000
timeout = 43200  # 12 hours
target = "test/fuzz/RecursiveProofFuzz.t.sol"

[campaign.recursive-proofs.mutations]
proofType = { type = "uint8", range = [0, 2] }  # GROTH16, PLONK, NOVA
proofCount = { type = "uint8", range = [1, 32] }
publicInputs = { type = "uint256[]", length = [1, 8], strategy = "random" }
verifierAddress = { type = "address", strategy = "random" }

[campaign.recursive-proofs.properties]
aggregation_validity = "Aggregated proof verifies iff all sub-proofs verify"
batch_size_limits = "Respects maximum batch size"
cross_system_compatibility = "Proofs translate between systems"

# ============================================================================
# CAMPAIGN: VIEW KEY REGISTRY
# Target: 250K iterations over 12 hours
# ============================================================================

[campaign.view-keys]
name = "View Key Registry Fuzz Campaign"
runs = 250000
timeout = 43200  # 12 hours
target = "test/fuzz/ViewKeyFuzz.t.sol"

[campaign.view-keys.mutations]
viewKey = { type = "bytes32", strategy = "random" }
permissionLevel = { type = "uint8", range = [0, 3] }  # NONE, BALANCE, TRANSACTION, FULL
timeLimit = { type = "uint256", range = [0, 31536000] }  # 0 to 1 year
delegatee = { type = "address", strategy = "random" }

[campaign.view-keys.properties]
permission_enforcement = "Only authorized viewers can access"
time_bounds = "Permissions expire correctly"
revocation = "Revoked keys cannot access"
delegation = "Delegated keys have correct permissions"

# ============================================================================
# CAMPAIGN: MERKLE TREES
# Target: 500K iterations over 12 hours
# ============================================================================

[campaign.merkle-trees]
name = "Merkle Tree Fuzz Campaign"
runs = 500000
timeout = 43200  # 12 hours
target = "test/fuzz/MerkleTreeFuzz.t.sol"

[campaign.merkle-trees.mutations]
leaf = { type = "bytes32", strategy = "random" }
siblings = { type = "bytes32[]", length = [1, 32], strategy = "random" }
pathIndices = { type = "bool[]", length = [1, 32], strategy = "random" }
depth = { type = "uint8", range = [1, 32] }

[campaign.merkle-trees.properties]
proof_validity = "Valid proofs verify correctly"
proof_soundness = "Invalid proofs fail verification"
determinism = "Same inputs produce same root"
collision_resistance = "Different leaves produce different roots"

# ============================================================================
# CAMPAIGN: CROSS-CHAIN PRIVACY HUB
# Target: 300K iterations over 24 hours
# ============================================================================

[campaign.privacy-hub]
name = "Cross-Chain Privacy Hub Fuzz Campaign"
runs = 300000
timeout = 86400  # 24 hours
target = "test/fuzz/PrivacyHubFuzz.t.sol"

[campaign.privacy-hub.mutations]
sourceChain = { type = "uint256", range = [1, 100000] }
targetChain = { type = "uint256", range = [1, 100000] }
proof = { type = "bytes", length = [32, 1024], strategy = "random" }
publicInputs = { type = "uint256[]", length = [1, 16], strategy = "random" }
privacyLevel = { type = "uint8", range = [0, 3] }

[campaign.privacy-hub.properties]
cross_chain_consistency = "Privacy maintained across chains"
proof_verification = "Only valid proofs accepted"
nullifier_sync = "Nullifiers correctly synced"
privacy_level_enforcement = "Correct privacy level applied"

# ============================================================================
# ECHIDNA CONFIGURATION
# ============================================================================

[echidna]
testLimit = 2000000
seqLen = 300
shrinkLimit = 10000
timeout = 172800  # 48 hours
workers = 8
corpus_dir = "echidna-corpus/privacy"

[echidna.filter]
contracts = [
    "StealthAddressRegistry",
    "RingConfidentialTransactions", 
    "UnifiedNullifierManager",
    "CrossChainPrivacyHub",
    "HomomorphicBalanceVerifier",
    "MLSAGSignatures",
    "PrivateRelayerNetwork",
    "ViewKeyRegistry"
]

# ============================================================================
# MEDUSA CONFIGURATION
# ============================================================================

[medusa]
workers = 8
timeout = 172800  # 48 hours
test_limit = 1000000
call_sequence_length = 200

[medusa.coverage]
enabled = true
corpus_directory = "medusa-corpus/privacy"

# ============================================================================
# AGGREGATE STATISTICS
# ============================================================================

[statistics]
total_runs = 6100000  # Sum of all campaigns
estimated_time_hours = 180  # ~7.5 days total
coverage_target = 98  # Percentage
mutation_strategies = ["random", "boundary", "arithmetic", "bitflip"]

# ============================================================================
# REPORTING
# ============================================================================

[reporting]
output_dir = "fuzzing-results/privacy"
format = ["json", "html", "markdown"]
include_coverage = true
include_corpus = true
alert_on_failure = true
slack_webhook = "${SLACK_WEBHOOK_URL}"
