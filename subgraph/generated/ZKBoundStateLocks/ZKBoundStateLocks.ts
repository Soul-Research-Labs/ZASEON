// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt,
} from "@graphprotocol/graph-ts";

export class DomainRegistered extends ethereum.Event {
  get params(): DomainRegistered__Params {
    return new DomainRegistered__Params(this);
  }
}

export class DomainRegistered__Params {
  _event: DomainRegistered;

  constructor(event: DomainRegistered) {
    this._event = event;
  }

  get domainSeparator(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get chainId(): i32 {
    return this._event.parameters[1].value.toI32();
  }

  get appId(): i32 {
    return this._event.parameters[2].value.toI32();
  }

  get epoch(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get name(): string {
    return this._event.parameters[4].value.toString();
  }
}

export class LockCreated extends ethereum.Event {
  get params(): LockCreated__Params {
    return new LockCreated__Params(this);
  }
}

export class LockCreated__Params {
  _event: LockCreated;

  constructor(event: LockCreated) {
    this._event = event;
  }

  get lockId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get oldStateCommitment(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get transitionPredicateHash(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }

  get policyHash(): Bytes {
    return this._event.parameters[3].value.toBytes();
  }

  get domainSeparator(): Bytes {
    return this._event.parameters[4].value.toBytes();
  }

  get lockedBy(): Address {
    return this._event.parameters[5].value.toAddress();
  }

  get unlockDeadline(): BigInt {
    return this._event.parameters[6].value.toBigInt();
  }
}

export class LockDisputed extends ethereum.Event {
  get params(): LockDisputed__Params {
    return new LockDisputed__Params(this);
  }
}

export class LockDisputed__Params {
  _event: LockDisputed;

  constructor(event: LockDisputed) {
    this._event = event;
  }

  get lockId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get disputer(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get conflictProofHash(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }

  get bondForfeited(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class LockUnlocked extends ethereum.Event {
  get params(): LockUnlocked__Params {
    return new LockUnlocked__Params(this);
  }
}

export class LockUnlocked__Params {
  _event: LockUnlocked;

  constructor(event: LockUnlocked) {
    this._event = event;
  }

  get lockId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get newStateCommitment(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get nullifier(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }

  get domainSeparator(): Bytes {
    return this._event.parameters[3].value.toBytes();
  }

  get unlockedBy(): Address {
    return this._event.parameters[4].value.toAddress();
  }
}

export class OptimisticUnlockFinalized extends ethereum.Event {
  get params(): OptimisticUnlockFinalized__Params {
    return new OptimisticUnlockFinalized__Params(this);
  }
}

export class OptimisticUnlockFinalized__Params {
  _event: OptimisticUnlockFinalized;

  constructor(event: OptimisticUnlockFinalized) {
    this._event = event;
  }

  get lockId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get unlocker(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class OptimisticUnlockInitiated extends ethereum.Event {
  get params(): OptimisticUnlockInitiated__Params {
    return new OptimisticUnlockInitiated__Params(this);
  }
}

export class OptimisticUnlockInitiated__Params {
  _event: OptimisticUnlockInitiated;

  constructor(event: OptimisticUnlockInitiated) {
    this._event = event;
  }

  get lockId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get unlocker(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get bondAmount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get finalizeAfter(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class Paused extends ethereum.Event {
  get params(): Paused__Params {
    return new Paused__Params(this);
  }
}

export class Paused__Params {
  _event: Paused;

  constructor(event: Paused) {
    this._event = event;
  }

  get account(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class RoleAdminChanged extends ethereum.Event {
  get params(): RoleAdminChanged__Params {
    return new RoleAdminChanged__Params(this);
  }
}

export class RoleAdminChanged__Params {
  _event: RoleAdminChanged;

  constructor(event: RoleAdminChanged) {
    this._event = event;
  }

  get role(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get previousAdminRole(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get newAdminRole(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }
}

export class RoleGranted extends ethereum.Event {
  get params(): RoleGranted__Params {
    return new RoleGranted__Params(this);
  }
}

export class RoleGranted__Params {
  _event: RoleGranted;

  constructor(event: RoleGranted) {
    this._event = event;
  }

  get role(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get account(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get sender(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class RoleRevoked extends ethereum.Event {
  get params(): RoleRevoked__Params {
    return new RoleRevoked__Params(this);
  }
}

export class RoleRevoked__Params {
  _event: RoleRevoked;

  constructor(event: RoleRevoked) {
    this._event = event;
  }

  get role(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get account(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get sender(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class Unpaused extends ethereum.Event {
  get params(): Unpaused__Params {
    return new Unpaused__Params(this);
  }
}

export class Unpaused__Params {
  _event: Unpaused;

  constructor(event: Unpaused) {
    this._event = event;
  }

  get account(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class VerifierRegistered extends ethereum.Event {
  get params(): VerifierRegistered__Params {
    return new VerifierRegistered__Params(this);
  }
}

export class VerifierRegistered__Params {
  _event: VerifierRegistered;

  constructor(event: VerifierRegistered) {
    this._event = event;
  }

  get verifierKeyHash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get verifierContract(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class ZKBoundStateLocks__domainsResult {
  value0: i32;
  value1: i32;
  value2: BigInt;
  value3: string;
  value4: boolean;
  value5: BigInt;

  constructor(
    value0: i32,
    value1: i32,
    value2: BigInt,
    value3: string,
    value4: boolean,
    value5: BigInt,
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
    this.value5 = value5;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set(
      "value0",
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(this.value0)),
    );
    map.set(
      "value1",
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(this.value1)),
    );
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromString(this.value3));
    map.set("value4", ethereum.Value.fromBoolean(this.value4));
    map.set("value5", ethereum.Value.fromUnsignedBigInt(this.value5));
    return map;
  }

  getChainId(): i32 {
    return this.value0;
  }

  getAppId(): i32 {
    return this.value1;
  }

  getEpoch(): BigInt {
    return this.value2;
  }

  getName(): string {
    return this.value3;
  }

  getIsActive(): boolean {
    return this.value4;
  }

  getRegisteredAt(): BigInt {
    return this.value5;
  }
}

export class ZKBoundStateLocks__getLockResultValue0Struct extends ethereum.Tuple {
  get lockId(): Bytes {
    return this[0].toBytes();
  }

  get oldStateCommitment(): Bytes {
    return this[1].toBytes();
  }

  get transitionPredicateHash(): Bytes {
    return this[2].toBytes();
  }

  get policyHash(): Bytes {
    return this[3].toBytes();
  }

  get domainSeparator(): Bytes {
    return this[4].toBytes();
  }

  get lockedBy(): Address {
    return this[5].toAddress();
  }

  get createdAt(): BigInt {
    return this[6].toBigInt();
  }

  get unlockDeadline(): BigInt {
    return this[7].toBigInt();
  }

  get isUnlocked(): boolean {
    return this[8].toBoolean();
  }
}

export class ZKBoundStateLocks__getStatsResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;
  value3: BigInt;
  value4: BigInt;

  constructor(
    value0: BigInt,
    value1: BigInt,
    value2: BigInt,
    value3: BigInt,
    value4: BigInt,
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromUnsignedBigInt(this.value3));
    map.set("value4", ethereum.Value.fromUnsignedBigInt(this.value4));
    return map;
  }

  getCreated(): BigInt {
    return this.value0;
  }

  getUnlocked(): BigInt {
    return this.value1;
  }

  getActive(): BigInt {
    return this.value2;
  }

  getOptimistic(): BigInt {
    return this.value3;
  }

  getDisputed(): BigInt {
    return this.value4;
  }
}

export class ZKBoundStateLocks__locksResult {
  value0: Bytes;
  value1: Bytes;
  value2: Bytes;
  value3: Bytes;
  value4: Bytes;
  value5: Address;
  value6: BigInt;
  value7: BigInt;
  value8: boolean;

  constructor(
    value0: Bytes,
    value1: Bytes,
    value2: Bytes,
    value3: Bytes,
    value4: Bytes,
    value5: Address,
    value6: BigInt,
    value7: BigInt,
    value8: boolean,
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
    this.value5 = value5;
    this.value6 = value6;
    this.value7 = value7;
    this.value8 = value8;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromFixedBytes(this.value0));
    map.set("value1", ethereum.Value.fromFixedBytes(this.value1));
    map.set("value2", ethereum.Value.fromFixedBytes(this.value2));
    map.set("value3", ethereum.Value.fromFixedBytes(this.value3));
    map.set("value4", ethereum.Value.fromFixedBytes(this.value4));
    map.set("value5", ethereum.Value.fromAddress(this.value5));
    map.set("value6", ethereum.Value.fromUnsignedBigInt(this.value6));
    map.set("value7", ethereum.Value.fromUnsignedBigInt(this.value7));
    map.set("value8", ethereum.Value.fromBoolean(this.value8));
    return map;
  }

  getLockId(): Bytes {
    return this.value0;
  }

  getOldStateCommitment(): Bytes {
    return this.value1;
  }

  getTransitionPredicateHash(): Bytes {
    return this.value2;
  }

  getPolicyHash(): Bytes {
    return this.value3;
  }

  getDomainSeparator(): Bytes {
    return this.value4;
  }

  getLockedBy(): Address {
    return this.value5;
  }

  getCreatedAt(): BigInt {
    return this.value6;
  }

  getUnlockDeadline(): BigInt {
    return this.value7;
  }

  getIsUnlocked(): boolean {
    return this.value8;
  }
}

export class ZKBoundStateLocks__optimisticUnlocksResult {
  value0: Address;
  value1: BigInt;
  value2: BigInt;
  value3: Bytes;
  value4: BigInt;
  value5: boolean;
  value6: Bytes;
  value7: Bytes;

  constructor(
    value0: Address,
    value1: BigInt,
    value2: BigInt,
    value3: Bytes,
    value4: BigInt,
    value5: boolean,
    value6: Bytes,
    value7: Bytes,
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
    this.value5 = value5;
    this.value6 = value6;
    this.value7 = value7;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromAddress(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromFixedBytes(this.value3));
    map.set("value4", ethereum.Value.fromUnsignedBigInt(this.value4));
    map.set("value5", ethereum.Value.fromBoolean(this.value5));
    map.set("value6", ethereum.Value.fromFixedBytes(this.value6));
    map.set("value7", ethereum.Value.fromFixedBytes(this.value7));
    return map;
  }

  getUnlocker(): Address {
    return this.value0;
  }

  getUnlockTime(): BigInt {
    return this.value1;
  }

  getBondAmount(): BigInt {
    return this.value2;
  }

  getProofHash(): Bytes {
    return this.value3;
  }

  getFinalizeAfter(): BigInt {
    return this.value4;
  }

  getDisputed(): boolean {
    return this.value5;
  }

  getNewStateCommitment(): Bytes {
    return this.value6;
  }

  getNullifier(): Bytes {
    return this.value7;
  }
}

export class ZKBoundStateLocks__unlockReceiptsResult {
  value0: Bytes;
  value1: Bytes;
  value2: Bytes;
  value3: Bytes;
  value4: Address;
  value5: BigInt;

  constructor(
    value0: Bytes,
    value1: Bytes,
    value2: Bytes,
    value3: Bytes,
    value4: Address,
    value5: BigInt,
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
    this.value5 = value5;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromFixedBytes(this.value0));
    map.set("value1", ethereum.Value.fromFixedBytes(this.value1));
    map.set("value2", ethereum.Value.fromFixedBytes(this.value2));
    map.set("value3", ethereum.Value.fromFixedBytes(this.value3));
    map.set("value4", ethereum.Value.fromAddress(this.value4));
    map.set("value5", ethereum.Value.fromUnsignedBigInt(this.value5));
    return map;
  }

  getLockId(): Bytes {
    return this.value0;
  }

  getNewStateCommitment(): Bytes {
    return this.value1;
  }

  getNullifier(): Bytes {
    return this.value2;
  }

  getDomainSeparator(): Bytes {
    return this.value3;
  }

  getUnlockedBy(): Address {
    return this.value4;
  }

  getUnlockedAt(): BigInt {
    return this.value5;
  }
}

export class ZKBoundStateLocks extends ethereum.SmartContract {
  static bind(address: Address): ZKBoundStateLocks {
    return new ZKBoundStateLocks("ZKBoundStateLocks", address);
  }

  DEFAULT_ADMIN_ROLE(): Bytes {
    let result = super.call(
      "DEFAULT_ADMIN_ROLE",
      "DEFAULT_ADMIN_ROLE():(bytes32)",
      [],
    );

    return result[0].toBytes();
  }

  try_DEFAULT_ADMIN_ROLE(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "DEFAULT_ADMIN_ROLE",
      "DEFAULT_ADMIN_ROLE():(bytes32)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  DISPUTE_RESOLVER_ROLE(): Bytes {
    let result = super.call(
      "DISPUTE_RESOLVER_ROLE",
      "DISPUTE_RESOLVER_ROLE():(bytes32)",
      [],
    );

    return result[0].toBytes();
  }

  try_DISPUTE_RESOLVER_ROLE(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "DISPUTE_RESOLVER_ROLE",
      "DISPUTE_RESOLVER_ROLE():(bytes32)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  DISPUTE_WINDOW(): BigInt {
    let result = super.call("DISPUTE_WINDOW", "DISPUTE_WINDOW():(uint256)", []);

    return result[0].toBigInt();
  }

  try_DISPUTE_WINDOW(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "DISPUTE_WINDOW",
      "DISPUTE_WINDOW():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  DOMAIN_ADMIN_ROLE(): Bytes {
    let result = super.call(
      "DOMAIN_ADMIN_ROLE",
      "DOMAIN_ADMIN_ROLE():(bytes32)",
      [],
    );

    return result[0].toBytes();
  }

  try_DOMAIN_ADMIN_ROLE(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "DOMAIN_ADMIN_ROLE",
      "DOMAIN_ADMIN_ROLE():(bytes32)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  LOCK_ADMIN_ROLE(): Bytes {
    let result = super.call(
      "LOCK_ADMIN_ROLE",
      "LOCK_ADMIN_ROLE():(bytes32)",
      [],
    );

    return result[0].toBytes();
  }

  try_LOCK_ADMIN_ROLE(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "LOCK_ADMIN_ROLE",
      "LOCK_ADMIN_ROLE():(bytes32)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  MAX_ACTIVE_LOCKS(): BigInt {
    let result = super.call(
      "MAX_ACTIVE_LOCKS",
      "MAX_ACTIVE_LOCKS():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_MAX_ACTIVE_LOCKS(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "MAX_ACTIVE_LOCKS",
      "MAX_ACTIVE_LOCKS():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  MIN_BOND_AMOUNT(): BigInt {
    let result = super.call(
      "MIN_BOND_AMOUNT",
      "MIN_BOND_AMOUNT():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_MIN_BOND_AMOUNT(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "MIN_BOND_AMOUNT",
      "MIN_BOND_AMOUNT():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  VERIFIER_ADMIN_ROLE(): Bytes {
    let result = super.call(
      "VERIFIER_ADMIN_ROLE",
      "VERIFIER_ADMIN_ROLE():(bytes32)",
      [],
    );

    return result[0].toBytes();
  }

  try_VERIFIER_ADMIN_ROLE(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "VERIFIER_ADMIN_ROLE",
      "VERIFIER_ADMIN_ROLE():(bytes32)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  canUnlock(lockId: Bytes): boolean {
    let result = super.call("canUnlock", "canUnlock(bytes32):(bool)", [
      ethereum.Value.fromFixedBytes(lockId),
    ]);

    return result[0].toBoolean();
  }

  try_canUnlock(lockId: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall("canUnlock", "canUnlock(bytes32):(bool)", [
      ethereum.Value.fromFixedBytes(lockId),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  commitmentPredecessor(param0: Bytes): Bytes {
    let result = super.call(
      "commitmentPredecessor",
      "commitmentPredecessor(bytes32):(bytes32)",
      [ethereum.Value.fromFixedBytes(param0)],
    );

    return result[0].toBytes();
  }

  try_commitmentPredecessor(param0: Bytes): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "commitmentPredecessor",
      "commitmentPredecessor(bytes32):(bytes32)",
      [ethereum.Value.fromFixedBytes(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  commitmentSuccessor(param0: Bytes): Bytes {
    let result = super.call(
      "commitmentSuccessor",
      "commitmentSuccessor(bytes32):(bytes32)",
      [ethereum.Value.fromFixedBytes(param0)],
    );

    return result[0].toBytes();
  }

  try_commitmentSuccessor(param0: Bytes): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "commitmentSuccessor",
      "commitmentSuccessor(bytes32):(bytes32)",
      [ethereum.Value.fromFixedBytes(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  createLock(
    oldStateCommitment: Bytes,
    transitionPredicateHash: Bytes,
    policyHash: Bytes,
    domainSeparator: Bytes,
    unlockDeadline: BigInt,
  ): Bytes {
    let result = super.call(
      "createLock",
      "createLock(bytes32,bytes32,bytes32,bytes32,uint64):(bytes32)",
      [
        ethereum.Value.fromFixedBytes(oldStateCommitment),
        ethereum.Value.fromFixedBytes(transitionPredicateHash),
        ethereum.Value.fromFixedBytes(policyHash),
        ethereum.Value.fromFixedBytes(domainSeparator),
        ethereum.Value.fromUnsignedBigInt(unlockDeadline),
      ],
    );

    return result[0].toBytes();
  }

  try_createLock(
    oldStateCommitment: Bytes,
    transitionPredicateHash: Bytes,
    policyHash: Bytes,
    domainSeparator: Bytes,
    unlockDeadline: BigInt,
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "createLock",
      "createLock(bytes32,bytes32,bytes32,bytes32,uint64):(bytes32)",
      [
        ethereum.Value.fromFixedBytes(oldStateCommitment),
        ethereum.Value.fromFixedBytes(transitionPredicateHash),
        ethereum.Value.fromFixedBytes(policyHash),
        ethereum.Value.fromFixedBytes(domainSeparator),
        ethereum.Value.fromUnsignedBigInt(unlockDeadline),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  domains(param0: Bytes): ZKBoundStateLocks__domainsResult {
    let result = super.call(
      "domains",
      "domains(bytes32):(uint16,uint16,uint32,string,bool,uint64)",
      [ethereum.Value.fromFixedBytes(param0)],
    );

    return new ZKBoundStateLocks__domainsResult(
      result[0].toI32(),
      result[1].toI32(),
      result[2].toBigInt(),
      result[3].toString(),
      result[4].toBoolean(),
      result[5].toBigInt(),
    );
  }

  try_domains(
    param0: Bytes,
  ): ethereum.CallResult<ZKBoundStateLocks__domainsResult> {
    let result = super.tryCall(
      "domains",
      "domains(bytes32):(uint16,uint16,uint32,string,bool,uint64)",
      [ethereum.Value.fromFixedBytes(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new ZKBoundStateLocks__domainsResult(
        value[0].toI32(),
        value[1].toI32(),
        value[2].toBigInt(),
        value[3].toString(),
        value[4].toBoolean(),
        value[5].toBigInt(),
      ),
    );
  }

  generateDomainSeparator(chainId: i32, appId: i32, epoch: BigInt): Bytes {
    let result = super.call(
      "generateDomainSeparator",
      "generateDomainSeparator(uint16,uint16,uint32):(bytes32)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(chainId)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(appId)),
        ethereum.Value.fromUnsignedBigInt(epoch),
      ],
    );

    return result[0].toBytes();
  }

  try_generateDomainSeparator(
    chainId: i32,
    appId: i32,
    epoch: BigInt,
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "generateDomainSeparator",
      "generateDomainSeparator(uint16,uint16,uint32):(bytes32)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(chainId)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(appId)),
        ethereum.Value.fromUnsignedBigInt(epoch),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  generateDomainSeparatorExtended(
    chainId: BigInt,
    appId: BigInt,
    epoch: BigInt,
  ): Bytes {
    let result = super.call(
      "generateDomainSeparatorExtended",
      "generateDomainSeparatorExtended(uint64,uint64,uint32):(bytes32)",
      [
        ethereum.Value.fromUnsignedBigInt(chainId),
        ethereum.Value.fromUnsignedBigInt(appId),
        ethereum.Value.fromUnsignedBigInt(epoch),
      ],
    );

    return result[0].toBytes();
  }

  try_generateDomainSeparatorExtended(
    chainId: BigInt,
    appId: BigInt,
    epoch: BigInt,
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "generateDomainSeparatorExtended",
      "generateDomainSeparatorExtended(uint64,uint64,uint32):(bytes32)",
      [
        ethereum.Value.fromUnsignedBigInt(chainId),
        ethereum.Value.fromUnsignedBigInt(appId),
        ethereum.Value.fromUnsignedBigInt(epoch),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  generateNullifier(
    secret: Bytes,
    lockId: Bytes,
    domainSeparator: Bytes,
  ): Bytes {
    let result = super.call(
      "generateNullifier",
      "generateNullifier(bytes32,bytes32,bytes32):(bytes32)",
      [
        ethereum.Value.fromFixedBytes(secret),
        ethereum.Value.fromFixedBytes(lockId),
        ethereum.Value.fromFixedBytes(domainSeparator),
      ],
    );

    return result[0].toBytes();
  }

  try_generateNullifier(
    secret: Bytes,
    lockId: Bytes,
    domainSeparator: Bytes,
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "generateNullifier",
      "generateNullifier(bytes32,bytes32,bytes32):(bytes32)",
      [
        ethereum.Value.fromFixedBytes(secret),
        ethereum.Value.fromFixedBytes(lockId),
        ethereum.Value.fromFixedBytes(domainSeparator),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getActiveLockCount(): BigInt {
    let result = super.call(
      "getActiveLockCount",
      "getActiveLockCount():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_getActiveLockCount(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getActiveLockCount",
      "getActiveLockCount():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getActiveLockIds(): Array<Bytes> {
    let result = super.call(
      "getActiveLockIds",
      "getActiveLockIds():(bytes32[])",
      [],
    );

    return result[0].toBytesArray();
  }

  try_getActiveLockIds(): ethereum.CallResult<Array<Bytes>> {
    let result = super.tryCall(
      "getActiveLockIds",
      "getActiveLockIds():(bytes32[])",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytesArray());
  }

  getCommitmentChain(startCommitment: Bytes, maxDepth: BigInt): Array<Bytes> {
    let result = super.call(
      "getCommitmentChain",
      "getCommitmentChain(bytes32,uint256):(bytes32[])",
      [
        ethereum.Value.fromFixedBytes(startCommitment),
        ethereum.Value.fromUnsignedBigInt(maxDepth),
      ],
    );

    return result[0].toBytesArray();
  }

  try_getCommitmentChain(
    startCommitment: Bytes,
    maxDepth: BigInt,
  ): ethereum.CallResult<Array<Bytes>> {
    let result = super.tryCall(
      "getCommitmentChain",
      "getCommitmentChain(bytes32,uint256):(bytes32[])",
      [
        ethereum.Value.fromFixedBytes(startCommitment),
        ethereum.Value.fromUnsignedBigInt(maxDepth),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytesArray());
  }

  getLock(lockId: Bytes): ZKBoundStateLocks__getLockResultValue0Struct {
    let result = super.call(
      "getLock",
      "getLock(bytes32):((bytes32,bytes32,bytes32,bytes32,bytes32,address,uint64,uint64,bool))",
      [ethereum.Value.fromFixedBytes(lockId)],
    );

    return changetype<ZKBoundStateLocks__getLockResultValue0Struct>(
      result[0].toTuple(),
    );
  }

  try_getLock(
    lockId: Bytes,
  ): ethereum.CallResult<ZKBoundStateLocks__getLockResultValue0Struct> {
    let result = super.tryCall(
      "getLock",
      "getLock(bytes32):((bytes32,bytes32,bytes32,bytes32,bytes32,address,uint64,uint64,bool))",
      [ethereum.Value.fromFixedBytes(lockId)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<ZKBoundStateLocks__getLockResultValue0Struct>(
        value[0].toTuple(),
      ),
    );
  }

  getRoleAdmin(role: Bytes): Bytes {
    let result = super.call("getRoleAdmin", "getRoleAdmin(bytes32):(bytes32)", [
      ethereum.Value.fromFixedBytes(role),
    ]);

    return result[0].toBytes();
  }

  try_getRoleAdmin(role: Bytes): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "getRoleAdmin",
      "getRoleAdmin(bytes32):(bytes32)",
      [ethereum.Value.fromFixedBytes(role)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getStats(): ZKBoundStateLocks__getStatsResult {
    let result = super.call(
      "getStats",
      "getStats():(uint256,uint256,uint256,uint256,uint256)",
      [],
    );

    return new ZKBoundStateLocks__getStatsResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt(),
      result[3].toBigInt(),
      result[4].toBigInt(),
    );
  }

  try_getStats(): ethereum.CallResult<ZKBoundStateLocks__getStatsResult> {
    let result = super.tryCall(
      "getStats",
      "getStats():(uint256,uint256,uint256,uint256,uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new ZKBoundStateLocks__getStatsResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt(),
        value[3].toBigInt(),
        value[4].toBigInt(),
      ),
    );
  }

  hasRole(role: Bytes, account: Address): boolean {
    let result = super.call("hasRole", "hasRole(bytes32,address):(bool)", [
      ethereum.Value.fromFixedBytes(role),
      ethereum.Value.fromAddress(account),
    ]);

    return result[0].toBoolean();
  }

  try_hasRole(role: Bytes, account: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("hasRole", "hasRole(bytes32,address):(bool)", [
      ethereum.Value.fromFixedBytes(role),
      ethereum.Value.fromAddress(account),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  locks(param0: Bytes): ZKBoundStateLocks__locksResult {
    let result = super.call(
      "locks",
      "locks(bytes32):(bytes32,bytes32,bytes32,bytes32,bytes32,address,uint64,uint64,bool)",
      [ethereum.Value.fromFixedBytes(param0)],
    );

    return new ZKBoundStateLocks__locksResult(
      result[0].toBytes(),
      result[1].toBytes(),
      result[2].toBytes(),
      result[3].toBytes(),
      result[4].toBytes(),
      result[5].toAddress(),
      result[6].toBigInt(),
      result[7].toBigInt(),
      result[8].toBoolean(),
    );
  }

  try_locks(
    param0: Bytes,
  ): ethereum.CallResult<ZKBoundStateLocks__locksResult> {
    let result = super.tryCall(
      "locks",
      "locks(bytes32):(bytes32,bytes32,bytes32,bytes32,bytes32,address,uint64,uint64,bool)",
      [ethereum.Value.fromFixedBytes(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new ZKBoundStateLocks__locksResult(
        value[0].toBytes(),
        value[1].toBytes(),
        value[2].toBytes(),
        value[3].toBytes(),
        value[4].toBytes(),
        value[5].toAddress(),
        value[6].toBigInt(),
        value[7].toBigInt(),
        value[8].toBoolean(),
      ),
    );
  }

  nullifierUsed(param0: Bytes): boolean {
    let result = super.call("nullifierUsed", "nullifierUsed(bytes32):(bool)", [
      ethereum.Value.fromFixedBytes(param0),
    ]);

    return result[0].toBoolean();
  }

  try_nullifierUsed(param0: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "nullifierUsed",
      "nullifierUsed(bytes32):(bool)",
      [ethereum.Value.fromFixedBytes(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  optimisticUnlocks(param0: Bytes): ZKBoundStateLocks__optimisticUnlocksResult {
    let result = super.call(
      "optimisticUnlocks",
      "optimisticUnlocks(bytes32):(address,uint64,uint128,bytes32,uint64,bool,bytes32,bytes32)",
      [ethereum.Value.fromFixedBytes(param0)],
    );

    return new ZKBoundStateLocks__optimisticUnlocksResult(
      result[0].toAddress(),
      result[1].toBigInt(),
      result[2].toBigInt(),
      result[3].toBytes(),
      result[4].toBigInt(),
      result[5].toBoolean(),
      result[6].toBytes(),
      result[7].toBytes(),
    );
  }

  try_optimisticUnlocks(
    param0: Bytes,
  ): ethereum.CallResult<ZKBoundStateLocks__optimisticUnlocksResult> {
    let result = super.tryCall(
      "optimisticUnlocks",
      "optimisticUnlocks(bytes32):(address,uint64,uint128,bytes32,uint64,bool,bytes32,bytes32)",
      [ethereum.Value.fromFixedBytes(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new ZKBoundStateLocks__optimisticUnlocksResult(
        value[0].toAddress(),
        value[1].toBigInt(),
        value[2].toBigInt(),
        value[3].toBytes(),
        value[4].toBigInt(),
        value[5].toBoolean(),
        value[6].toBytes(),
        value[7].toBytes(),
      ),
    );
  }

  paused(): boolean {
    let result = super.call("paused", "paused():(bool)", []);

    return result[0].toBoolean();
  }

  try_paused(): ethereum.CallResult<boolean> {
    let result = super.tryCall("paused", "paused():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  proofVerifier(): Address {
    let result = super.call("proofVerifier", "proofVerifier():(address)", []);

    return result[0].toAddress();
  }

  try_proofVerifier(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "proofVerifier",
      "proofVerifier():(address)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  registerDomain(chainId: i32, appId: i32, epoch: BigInt, name: string): Bytes {
    let result = super.call(
      "registerDomain",
      "registerDomain(uint16,uint16,uint32,string):(bytes32)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(chainId)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(appId)),
        ethereum.Value.fromUnsignedBigInt(epoch),
        ethereum.Value.fromString(name),
      ],
    );

    return result[0].toBytes();
  }

  try_registerDomain(
    chainId: i32,
    appId: i32,
    epoch: BigInt,
    name: string,
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "registerDomain",
      "registerDomain(uint16,uint16,uint32,string):(bytes32)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(chainId)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(appId)),
        ethereum.Value.fromUnsignedBigInt(epoch),
        ethereum.Value.fromString(name),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  supportsInterface(interfaceId: Bytes): boolean {
    let result = super.call(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(interfaceId)],
    );

    return result[0].toBoolean();
  }

  try_supportsInterface(interfaceId: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(interfaceId)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  totalDisputes(): BigInt {
    let result = super.call("totalDisputes", "totalDisputes():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalDisputes(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "totalDisputes",
      "totalDisputes():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  totalLocksCreated(): BigInt {
    let result = super.call(
      "totalLocksCreated",
      "totalLocksCreated():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_totalLocksCreated(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "totalLocksCreated",
      "totalLocksCreated():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  totalLocksUnlocked(): BigInt {
    let result = super.call(
      "totalLocksUnlocked",
      "totalLocksUnlocked():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_totalLocksUnlocked(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "totalLocksUnlocked",
      "totalLocksUnlocked():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  totalOptimisticUnlocks(): BigInt {
    let result = super.call(
      "totalOptimisticUnlocks",
      "totalOptimisticUnlocks():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_totalOptimisticUnlocks(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "totalOptimisticUnlocks",
      "totalOptimisticUnlocks():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  unlockReceipts(param0: Bytes): ZKBoundStateLocks__unlockReceiptsResult {
    let result = super.call(
      "unlockReceipts",
      "unlockReceipts(bytes32):(bytes32,bytes32,bytes32,bytes32,address,uint64)",
      [ethereum.Value.fromFixedBytes(param0)],
    );

    return new ZKBoundStateLocks__unlockReceiptsResult(
      result[0].toBytes(),
      result[1].toBytes(),
      result[2].toBytes(),
      result[3].toBytes(),
      result[4].toAddress(),
      result[5].toBigInt(),
    );
  }

  try_unlockReceipts(
    param0: Bytes,
  ): ethereum.CallResult<ZKBoundStateLocks__unlockReceiptsResult> {
    let result = super.tryCall(
      "unlockReceipts",
      "unlockReceipts(bytes32):(bytes32,bytes32,bytes32,bytes32,address,uint64)",
      [ethereum.Value.fromFixedBytes(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new ZKBoundStateLocks__unlockReceiptsResult(
        value[0].toBytes(),
        value[1].toBytes(),
        value[2].toBytes(),
        value[3].toBytes(),
        value[4].toAddress(),
        value[5].toBigInt(),
      ),
    );
  }

  userLockCount(param0: Address): BigInt {
    let result = super.call(
      "userLockCount",
      "userLockCount(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );

    return result[0].toBigInt();
  }

  try_userLockCount(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "userLockCount",
      "userLockCount(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  verifiers(param0: Bytes): Address {
    let result = super.call("verifiers", "verifiers(bytes32):(address)", [
      ethereum.Value.fromFixedBytes(param0),
    ]);

    return result[0].toAddress();
  }

  try_verifiers(param0: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall("verifiers", "verifiers(bytes32):(address)", [
      ethereum.Value.fromFixedBytes(param0),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _proofVerifier(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ChallengeOptimisticUnlockCall extends ethereum.Call {
  get inputs(): ChallengeOptimisticUnlockCall__Inputs {
    return new ChallengeOptimisticUnlockCall__Inputs(this);
  }

  get outputs(): ChallengeOptimisticUnlockCall__Outputs {
    return new ChallengeOptimisticUnlockCall__Outputs(this);
  }
}

export class ChallengeOptimisticUnlockCall__Inputs {
  _call: ChallengeOptimisticUnlockCall;

  constructor(call: ChallengeOptimisticUnlockCall) {
    this._call = call;
  }

  get lockId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get conflictProof(): ChallengeOptimisticUnlockCallConflictProofStruct {
    return changetype<ChallengeOptimisticUnlockCallConflictProofStruct>(
      this._call.inputValues[1].value.toTuple(),
    );
  }
}

export class ChallengeOptimisticUnlockCall__Outputs {
  _call: ChallengeOptimisticUnlockCall;

  constructor(call: ChallengeOptimisticUnlockCall) {
    this._call = call;
  }
}

export class ChallengeOptimisticUnlockCallConflictProofStruct extends ethereum.Tuple {
  get lockId(): Bytes {
    return this[0].toBytes();
  }

  get zkProof(): Bytes {
    return this[1].toBytes();
  }

  get newStateCommitment(): Bytes {
    return this[2].toBytes();
  }

  get nullifier(): Bytes {
    return this[3].toBytes();
  }

  get verifierKeyHash(): Bytes {
    return this[4].toBytes();
  }

  get auxiliaryData(): Bytes {
    return this[5].toBytes();
  }
}

export class CreateLockCall extends ethereum.Call {
  get inputs(): CreateLockCall__Inputs {
    return new CreateLockCall__Inputs(this);
  }

  get outputs(): CreateLockCall__Outputs {
    return new CreateLockCall__Outputs(this);
  }
}

export class CreateLockCall__Inputs {
  _call: CreateLockCall;

  constructor(call: CreateLockCall) {
    this._call = call;
  }

  get oldStateCommitment(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get transitionPredicateHash(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get policyHash(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get domainSeparator(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }

  get unlockDeadline(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }
}

export class CreateLockCall__Outputs {
  _call: CreateLockCall;

  constructor(call: CreateLockCall) {
    this._call = call;
  }

  get lockId(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class FinalizeOptimisticUnlockCall extends ethereum.Call {
  get inputs(): FinalizeOptimisticUnlockCall__Inputs {
    return new FinalizeOptimisticUnlockCall__Inputs(this);
  }

  get outputs(): FinalizeOptimisticUnlockCall__Outputs {
    return new FinalizeOptimisticUnlockCall__Outputs(this);
  }
}

export class FinalizeOptimisticUnlockCall__Inputs {
  _call: FinalizeOptimisticUnlockCall;

  constructor(call: FinalizeOptimisticUnlockCall) {
    this._call = call;
  }

  get lockId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class FinalizeOptimisticUnlockCall__Outputs {
  _call: FinalizeOptimisticUnlockCall;

  constructor(call: FinalizeOptimisticUnlockCall) {
    this._call = call;
  }
}

export class GrantRoleCall extends ethereum.Call {
  get inputs(): GrantRoleCall__Inputs {
    return new GrantRoleCall__Inputs(this);
  }

  get outputs(): GrantRoleCall__Outputs {
    return new GrantRoleCall__Outputs(this);
  }
}

export class GrantRoleCall__Inputs {
  _call: GrantRoleCall;

  constructor(call: GrantRoleCall) {
    this._call = call;
  }

  get role(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get account(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class GrantRoleCall__Outputs {
  _call: GrantRoleCall;

  constructor(call: GrantRoleCall) {
    this._call = call;
  }
}

export class OptimisticUnlockCall extends ethereum.Call {
  get inputs(): OptimisticUnlockCall__Inputs {
    return new OptimisticUnlockCall__Inputs(this);
  }

  get outputs(): OptimisticUnlockCall__Outputs {
    return new OptimisticUnlockCall__Outputs(this);
  }
}

export class OptimisticUnlockCall__Inputs {
  _call: OptimisticUnlockCall;

  constructor(call: OptimisticUnlockCall) {
    this._call = call;
  }

  get unlockProof(): OptimisticUnlockCallUnlockProofStruct {
    return changetype<OptimisticUnlockCallUnlockProofStruct>(
      this._call.inputValues[0].value.toTuple(),
    );
  }
}

export class OptimisticUnlockCall__Outputs {
  _call: OptimisticUnlockCall;

  constructor(call: OptimisticUnlockCall) {
    this._call = call;
  }
}

export class OptimisticUnlockCallUnlockProofStruct extends ethereum.Tuple {
  get lockId(): Bytes {
    return this[0].toBytes();
  }

  get zkProof(): Bytes {
    return this[1].toBytes();
  }

  get newStateCommitment(): Bytes {
    return this[2].toBytes();
  }

  get nullifier(): Bytes {
    return this[3].toBytes();
  }

  get verifierKeyHash(): Bytes {
    return this[4].toBytes();
  }

  get auxiliaryData(): Bytes {
    return this[5].toBytes();
  }
}

export class PauseCall extends ethereum.Call {
  get inputs(): PauseCall__Inputs {
    return new PauseCall__Inputs(this);
  }

  get outputs(): PauseCall__Outputs {
    return new PauseCall__Outputs(this);
  }
}

export class PauseCall__Inputs {
  _call: PauseCall;

  constructor(call: PauseCall) {
    this._call = call;
  }
}

export class PauseCall__Outputs {
  _call: PauseCall;

  constructor(call: PauseCall) {
    this._call = call;
  }
}

export class RegisterDomainCall extends ethereum.Call {
  get inputs(): RegisterDomainCall__Inputs {
    return new RegisterDomainCall__Inputs(this);
  }

  get outputs(): RegisterDomainCall__Outputs {
    return new RegisterDomainCall__Outputs(this);
  }
}

export class RegisterDomainCall__Inputs {
  _call: RegisterDomainCall;

  constructor(call: RegisterDomainCall) {
    this._call = call;
  }

  get chainId(): i32 {
    return this._call.inputValues[0].value.toI32();
  }

  get appId(): i32 {
    return this._call.inputValues[1].value.toI32();
  }

  get epoch(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get name(): string {
    return this._call.inputValues[3].value.toString();
  }
}

export class RegisterDomainCall__Outputs {
  _call: RegisterDomainCall;

  constructor(call: RegisterDomainCall) {
    this._call = call;
  }

  get domainSeparator(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class RegisterVerifierCall extends ethereum.Call {
  get inputs(): RegisterVerifierCall__Inputs {
    return new RegisterVerifierCall__Inputs(this);
  }

  get outputs(): RegisterVerifierCall__Outputs {
    return new RegisterVerifierCall__Outputs(this);
  }
}

export class RegisterVerifierCall__Inputs {
  _call: RegisterVerifierCall;

  constructor(call: RegisterVerifierCall) {
    this._call = call;
  }

  get verifierKeyHash(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get verifierContract(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class RegisterVerifierCall__Outputs {
  _call: RegisterVerifierCall;

  constructor(call: RegisterVerifierCall) {
    this._call = call;
  }
}

export class RenounceRoleCall extends ethereum.Call {
  get inputs(): RenounceRoleCall__Inputs {
    return new RenounceRoleCall__Inputs(this);
  }

  get outputs(): RenounceRoleCall__Outputs {
    return new RenounceRoleCall__Outputs(this);
  }
}

export class RenounceRoleCall__Inputs {
  _call: RenounceRoleCall;

  constructor(call: RenounceRoleCall) {
    this._call = call;
  }

  get role(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get callerConfirmation(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class RenounceRoleCall__Outputs {
  _call: RenounceRoleCall;

  constructor(call: RenounceRoleCall) {
    this._call = call;
  }
}

export class RevokeRoleCall extends ethereum.Call {
  get inputs(): RevokeRoleCall__Inputs {
    return new RevokeRoleCall__Inputs(this);
  }

  get outputs(): RevokeRoleCall__Outputs {
    return new RevokeRoleCall__Outputs(this);
  }
}

export class RevokeRoleCall__Inputs {
  _call: RevokeRoleCall;

  constructor(call: RevokeRoleCall) {
    this._call = call;
  }

  get role(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get account(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class RevokeRoleCall__Outputs {
  _call: RevokeRoleCall;

  constructor(call: RevokeRoleCall) {
    this._call = call;
  }
}

export class SetProofVerifierCall extends ethereum.Call {
  get inputs(): SetProofVerifierCall__Inputs {
    return new SetProofVerifierCall__Inputs(this);
  }

  get outputs(): SetProofVerifierCall__Outputs {
    return new SetProofVerifierCall__Outputs(this);
  }
}

export class SetProofVerifierCall__Inputs {
  _call: SetProofVerifierCall;

  constructor(call: SetProofVerifierCall) {
    this._call = call;
  }

  get _proofVerifier(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetProofVerifierCall__Outputs {
  _call: SetProofVerifierCall;

  constructor(call: SetProofVerifierCall) {
    this._call = call;
  }
}

export class UnlockCall extends ethereum.Call {
  get inputs(): UnlockCall__Inputs {
    return new UnlockCall__Inputs(this);
  }

  get outputs(): UnlockCall__Outputs {
    return new UnlockCall__Outputs(this);
  }
}

export class UnlockCall__Inputs {
  _call: UnlockCall;

  constructor(call: UnlockCall) {
    this._call = call;
  }

  get unlockProof(): UnlockCallUnlockProofStruct {
    return changetype<UnlockCallUnlockProofStruct>(
      this._call.inputValues[0].value.toTuple(),
    );
  }
}

export class UnlockCall__Outputs {
  _call: UnlockCall;

  constructor(call: UnlockCall) {
    this._call = call;
  }
}

export class UnlockCallUnlockProofStruct extends ethereum.Tuple {
  get lockId(): Bytes {
    return this[0].toBytes();
  }

  get zkProof(): Bytes {
    return this[1].toBytes();
  }

  get newStateCommitment(): Bytes {
    return this[2].toBytes();
  }

  get nullifier(): Bytes {
    return this[3].toBytes();
  }

  get verifierKeyHash(): Bytes {
    return this[4].toBytes();
  }

  get auxiliaryData(): Bytes {
    return this[5].toBytes();
  }
}

export class UnpauseCall extends ethereum.Call {
  get inputs(): UnpauseCall__Inputs {
    return new UnpauseCall__Inputs(this);
  }

  get outputs(): UnpauseCall__Outputs {
    return new UnpauseCall__Outputs(this);
  }
}

export class UnpauseCall__Inputs {
  _call: UnpauseCall;

  constructor(call: UnpauseCall) {
    this._call = call;
  }
}

export class UnpauseCall__Outputs {
  _call: UnpauseCall;

  constructor(call: UnpauseCall) {
    this._call = call;
  }
}
