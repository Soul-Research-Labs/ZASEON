// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../../contracts/verifiers/adapters/UltraHonkAdapter.sol";

// Import the generated verifier interface
interface IHonkVerifier {
    function verify(
        bytes calldata _proof,
        bytes32[] calldata _publicInputs
    ) external view returns (bool);
}

/**
 * @title ZKVerifierIntegrationTest
 * @notice Tests that the generated Noir/Barretenberg verifiers deploy correctly
 *         and the UltraHonkAdapter bridges the IProofVerifier interface.
 * @dev Real proof verification requires proof artifacts generated by bb.
 *      This test validates:
 *      1. HonkVerifier deploys and is callable
 *      2. UltraHonkAdapter correctly wraps it behind IProofVerifier
 *      3. Invalid proofs get rejected
 *      4. Public input count is correct
 */
contract ZKVerifierIntegrationTest is Test {
    // We test with the NullifierVerifier (20 public inputs)
    // The contract name was changed from HonkVerifier to NullifierVerifier

    UltraHonkAdapter public adapter;
    address public honkVerifier;

    function setUp() public {
        // Deploy the generated NullifierVerifier
        // Using deployCode to deploy a contract by artifact name
        honkVerifier = deployCode("NullifierVerifier.sol:NullifierVerifier");

        // Deploy the adapter wrapping the HonkVerifier
        adapter = new UltraHonkAdapter(
            honkVerifier,
            20, // NullifierVerifier has 20 public inputs
            keccak256("nullifier")
        );
    }

    function test_verifierDeployed() public view {
        assertTrue(honkVerifier != address(0), "Verifier not deployed");
        assertTrue(honkVerifier.code.length > 0, "Verifier has no code");
    }

    function test_adapterIsReady() public view {
        assertTrue(adapter.isReady(), "Adapter not ready");
    }

    function test_adapterPublicInputCount() public view {
        assertEq(adapter.getPublicInputCount(), 20, "Wrong public input count");
    }

    function test_adapterCircuitId() public view {
        assertEq(
            adapter.circuitId(),
            keccak256("nullifier"),
            "Wrong circuit ID"
        );
    }

    function test_adapterHonkVerifierAddress() public view {
        assertEq(
            address(adapter.honkVerifier()),
            honkVerifier,
            "Wrong verifier address"
        );
    }

    function test_invalidProofRejected() public {
        // Create random invalid proof bytes
        bytes memory invalidProof = new bytes(100);
        for (uint256 i = 0; i < 100; i++) {
            invalidProof[i] = bytes1(uint8(i));
        }

        // Create 20 dummy public inputs
        uint256[] memory publicInputs = new uint256[](20);
        for (uint256 i = 0; i < 20; i++) {
            publicInputs[i] = i + 1;
        }

        // Should revert or return false for invalid proof
        // The HonkVerifier will revert on malformed proofs
        vm.expectRevert();
        adapter.verify(invalidProof, publicInputs);
    }

    function test_wrongPublicInputCountReverts() public {
        bytes memory proof = new bytes(64);

        // Wrong number of public inputs (5 instead of 20)
        uint256[] memory publicInputs = new uint256[](5);

        vm.expectRevert(
            abi.encodeWithSelector(
                UltraHonkAdapter.InvalidPublicInputCount.selector,
                20,
                5
            )
        );
        adapter.verify(proof, publicInputs);
    }

    function test_adapterRejectsZeroVerifier() public {
        vm.expectRevert("Zero verifier address");
        new UltraHonkAdapter(address(0), 20, keccak256("test"));
    }

    // ===== Deploy all 5 core verifiers =====

    function test_stateTransferVerifierDeploys() public {
        address v = deployCode(
            "contracts/verifiers/generated/StateTransferVerifier.sol:StateTransferVerifier"
        );
        assertTrue(v.code.length > 0, "StateTransferVerifier empty");
    }

    function test_containerVerifierDeploys() public {
        address v = deployCode("ContainerVerifier.sol:ContainerVerifier");
        assertTrue(v.code.length > 0, "ContainerVerifier empty");
    }

    function test_stateCommitmentVerifierDeploys() public {
        address v = deployCode(
            "contracts/verifiers/generated/StateCommitmentVerifier.sol:StateCommitmentVerifier"
        );
        assertTrue(v.code.length > 0, "StateCommitmentVerifier empty");
    }

    function test_crossChainProofVerifierDeploys() public {
        address v = deployCode(
            "contracts/verifiers/generated/CrossChainProofVerifier.sol:CrossChainProofVerifier"
        );
        assertTrue(v.code.length > 0, "CrossChainProofVerifier empty");
    }
}
